% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{book}
\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Simulación Estadística},
  pdfauthor={Rubén Fernández Casal (ruben.fcasal@udc.es), Ricardo Cao (rcao@udc.es)},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\usepackage{booktabs}
\usepackage[a4paper, top=3.25cm, bottom=2.5cm, left=3cm, right=2.5cm]{geometry}
% \usepackage{fontspec}
% \setmainfont{Arial}
% \usepackage{amsthm}
% Espacio después de teorema
% Basado en https://tex.stackexchange.com/questions/37797/theorem-environment-line-break-after-label
% \newtheoremstyle{break}
%   {\topsep}{\topsep}% Space above and below
%   {\itshape}{}%       Body font, Indent amoun
%   {\bfseries}{}%      Theorem head font, Punctuation after theorem head
%   {\newline}%         Space after theorem head
%   {}%                 Theorem head spec (can be left empty, meaning ‘normal’ )
% Problemas con listas  https://tex.stackexchange.com/questions/8110/is-it-possible-to-skip-the-first-line-in-a-theorem-environment

\usepackage{ntheorem}
\theoremstyle{break}
\theoremheaderfont{\normalfont\bfseries}
\theorembodyfont{\normalfont}
\theorempreskip{\smallskipamount}
\theorempostskip{\smallskipamount}
\theoremprework{\bigskip\hrule\leavevmode}
\theoremseparator{\smallskip}
\theorempostwork{\bigskip\hrule\bigskip}
\newtheorem{theorem}{Teorema}[chapter]
\theoremprework{\bigskip\hrule\leavevmode}
\theorempostwork{\bigskip\hrule\bigskip}
\newtheorem{conjecture}{Algoritmo}[chapter]
\newtheorem{lemma}{Lema}[chapter]
\newtheorem{corollary}{Corolario}[chapter]
\newtheorem{proposition}{Proposición}[chapter]
\newtheorem{definition}{Definición}[chapter]
\newtheorem{hypothesis}{Hipótesis}[chapter]
\theoremprework{\bigskip\leavevmode}
\theorempostwork{\vspace*{-\bigskipamount}\vspace*{-\medskipamount}}
\newtheorem{example}{Ejemplo}[chapter]
\theoremprework{\bigskip\leavevmode}
\theorempostwork{\vspace*{-\bigskipamount}\vspace*{-\medskipamount}}
\newtheorem{exercise}{Ejercicio}[chapter]
\theoremstyle{nonumberplain}
\theoremheaderfont{\normalfont\itshape}
\theoremseparator{:}
% \theorempostwork{\hrule}
\newtheorem{remark}{Nota}
\newtheorem{solution}{Solución}
\newtheorem{proof}{Demostración}


\ifxetex
  \usepackage{polyglossia}
  \setmainlanguage{spanish}
  % Tabla en lugar de cuadro
  \gappto\captionsspanish{\renewcommand{\tablename}{Tabla}
          \renewcommand{\listtablename}{Índice de tablas}}

\else
  \usepackage[spanish,es-tabla]{babel}
\fi
\makeatletter
\def\thm@space@setup{%
  \thm@preskip=8pt plus 2pt minus 4pt
  \thm@postskip=\thm@preskip
}
\makeatother
\ifluatex
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\usepackage[]{natbib}
\bibliographystyle{apalike}

\title{Simulación Estadística}
\author{Rubén Fernández Casal (\href{mailto:ruben.fcasal@udc.es}{\nolinkurl{ruben.fcasal@udc.es}}), Ricardo Cao (\href{mailto:rcao@udc.es}{\nolinkurl{rcao@udc.es}})}
\date{Edición: Agosto de 2022. Impresión: 2022-08-23}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\hypertarget{pruxf3logo}{%
\chapter*{Prólogo}\label{pruxf3logo}}
\addcontentsline{toc}{chapter}{Prólogo}

Este libro contiene los apuntes de la asignatura de \href{http://eamo.usc.es/pub/mte/index.php/es/?option=com_content\&view=article\&id=2201\&idm=13\&a\%C3\%B1o=2019}{Simulación Estadística} del \href{http://eio.usc.es/pub/mte}{Máster en Técnicas Estadísticas}.

Este libro ha sido escrito en \href{http://rmarkdown.rstudio.com}{R-Markdown} empleando el paquete \href{https://bookdown.org/yihui/bookdown/}{\texttt{bookdown}} y está disponible en el repositorio Github: \href{https://github.com/rubenfcasal/simbook}{rubenfcasal/simbook}.
Se puede acceder a la versión en línea a través del siguiente enlace:

\url{https://rubenfcasal.github.io/simbook/index.html}.

donde puede descargarse en formato \href{https://rubenfcasal.github.io/simbook/Simulacion.pdf}{pdf}.

Para poder ejecutar los ejemplos mostrados en el libro es recomendable emplear el paquete \href{https://rubenfcasal.github.io/simres}{\texttt{simres}}, \textbf{\emph{no disponible actualmente en CRAN}}, aunque se puede instalar la versión de desarrollo en \href{https://github.com/rubenfcasal/simres}{GitHub}):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# install.packages("remotes")}
\NormalTok{remotes}\SpecialCharTok{::}\FunctionTok{install\_github}\NormalTok{(}\StringTok{"rubenfcasal/simres"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Alternativamente se pueden emplear los ficheros de la carpeta \emph{codigo}.

Para instalar los paquetes necesarios se puede emplear el siguiente comando:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pkgs }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}tictoc\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}boot\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}randtoolbox\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}MASS\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}DEoptim\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}nortest\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}geoR\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}copula\textquotesingle{}}\NormalTok{,}
          \StringTok{\textquotesingle{}sm\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}car\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}tseries\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}forecast\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}plot3D\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}rgl\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}rngWELL\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}randtoolbox\textquotesingle{}}\NormalTok{)}
\FunctionTok{install.packages}\NormalTok{(}\FunctionTok{setdiff}\NormalTok{(pkgs, }\FunctionTok{installed.packages}\NormalTok{()[,}\StringTok{"Package"}\NormalTok{]), }
                 \AttributeTok{dependencies =} \ConstantTok{TRUE}\NormalTok{)}

\CommentTok{\# Si aparecen errores debidos a incompatibilidades entre las versiones de los paquetes, }
\CommentTok{\# probar a ejecutar en lugar de lo anterior:}
\CommentTok{\# install.packages(pkgs, dependencies = TRUE) \# Instala todos...}
\end{Highlighting}
\end{Shaded}

Para generar el libro (compilar) serán necesarios paquetes adicionales,
para lo que se recomendaría consultar el libro de \href{https://rubenfcasal.github.io/bookdown_intro}{``Escritura de libros con bookdown''} en castellano.
Pueden ser también de interés los enlaces mostrados en el Apéndice \ref{links}.

\begin{flushleft}\includegraphics[width=0.1\linewidth]{images/by-nc-nd-88x31} \end{flushleft}

Este obra está bajo una licencia de \href{https://creativecommons.org/licenses/by-nc-nd/4.0/deed.es_ES}{Creative Commons Reconocimiento-NoComercial-SinObraDerivada 4.0 Internacional}
(esperamos poder liberarlo bajo una licencia menos restrictiva más adelante\ldots).

\hypertarget{intro}{%
\chapter{Introducción a la simulación}\label{intro}}

Cuando pensamos en ciencia pensamos en experimentos y en modelos.
Se experimenta una y otra vez sobre el fenómeno real que se desea conocer mejor para, con la información así acumulada, construir un modelo teórico, que no es sino una representación simplificada (más o menos acertada) del fenómeno real.
Como el modelo se formula en términos matemáticos, en general es susceptible de un estudio analítico del que poder sacar conclusiones.

La simulación ofrece una alternativa a esa última fase del proceso, y sustituye (en parte o completamente) el estudio analítico por más experimentación, pero esta vez sobre el propio modelo en lugar de sobre la realidad.

Así, se puede definir la \emph{simulación} como una técnica que consiste en realizar experimentos sobre el modelo de un sistema (experimentos de muestreo si la simulación incorpora aleatoriedad), con el objetivo de recopilar información bajo determinadas condiciones.

\hypertarget{conceptos-buxe1sicos}{%
\section{Conceptos básicos}\label{conceptos-buxe1sicos}}

La experimentación directa sobre la realidad puede tener muchos inconvenientes, entre otros:

\begin{itemize}
\item
  Coste elevado: por ejemplo cuando las pruebas son destructivas o si es necesario esperar mucho tiempo para observar los resultados.
\item
  Puede no ser ética: por ejemplo la experimentación sobre seres humanos o la dispersión de un contaminante.
\item
  Puede resultar imposible: por ejemplo cuando se trata de un acontecimiento futuro o una alternativa en el pasado.
\end{itemize}

Además la realidad puede ser demasiado compleja como para ser estudiada directamente y resultar preferible trabajar con un modelo del sistema real.
Un modelo no es más que un conjunto de variables junto con ecuaciones matemáticas que las relacionan y restricciones sobre dichas variables.
Habría dos tipos de modelos:

\begin{itemize}
\item
  Modelos deterministas: en los que bajo las mismas condiciones (fijados los valores de las variables explicativas) se obtienen siempre los mismos resultados.
\item
  Modelos estocásticos (con componente aleatoria): tienen en cuenta la incertidumbre asociada al modelo. Tradicionalmente se supone que esta incertidumbre es debida a que no se dispone de toda la información sobre las variables que influyen en el fenómeno en estudio (puede ser debida simplemente a que haya errores de medida), lo que se conoce como \emph{aleatoriedad aparente}:

  \begin{quote}
  ``Nothing in Nature is random\ldots{} a thing appears random only through the incompleteness of our knowledge.''

  --- Spinoza, Baruch (Ethics, 1677)
  \end{quote}

  aunque hoy en día gana peso la idea de la física cuántica de que en el fondo hay una \emph{aleatoriedad intrínseca}\footnote{Como ejemplo, en física cuántica, la \href{https://es.wikipedia.org/wiki/Ecuaci\%C3\%B3n_de_Schr\%C3\%B6dinger}{ecuación de Schrödinger} es un modelo determinista que describe la evolución en el tiempo de la función de onda de un sistema. Sin embargo, como las funciones de onda pueden cambiar de forma aleatoria al realizar una medición, se emplea la \href{https://en.wikipedia.org/wiki/Born_rule}{regla de Born} para modelar las probabilidades de las distintas posibilidades (algo que inicialmente generó rechazo, dió lugar a la famosa frase de Einstein ``Dios no juega a los dados'', pero experimentos posteriores parecen confirmar). Por tanto en la práctica se emplea un modelo estocástico.}.
\end{itemize}

La modelización es una etapa presente en la mayor parte de los trabajos de investigación, especialmente en las ciencias experimentales.
El modelo debería considerar las variables más relevantes para explicar el fenómeno en estudio y las principales relaciones entre ellas.
La inferencia estadística proporciona herramientas para estimar los parámetros y contrastar la validez de un modelo estocástico a partir de los datos observados.

La idea es emplear el modelo, asumiendo que es válido, para resolver el problema de interés.
Si se puede obtener la solución de forma analítica, esta suele ser exacta (aunque en ocasiones solo se dispone de soluciones aproximadas, basadas en resultados asintóticos, o que dependen de suposiciones que pueden ser cuestionables) y a menudo la resolución también es rápida.
Cuando la solución no se puede obtener de modo analítico (o si la aproximación disponible no es adecuada) se puede recurrir a la simulación.
De esta forma se pueden obtener resultados para un conjunto más amplio de modelos, que pueden ser mucho más complejos.

Nos centraremos en el caso de la \emph{simulación estocástica}: las conclusiones se obtienen generando repetidamente simulaciones del modelo aleatorio.
Muchas veces se emplea la denominación de \emph{método Monte Carlo}\footnote{Estos métodos surgieron a finales de la década de 1940 como resultado del trabajo realizado por Stanislaw Ulam y John von Neumann en el proyecto Manhattan para el desarrollo de la bomba atómica. Al parecer, como se trataba de una investigación secreta, Nicholas Metropolis sugirió emplear el nombre clave de ``Monte-Carlo'' en referencia al casino de Monte Carlo de Mónaco.} como sinónimo de simulación estocástica, pero realmente se trata de métodos especializados que emplean simulación para resolver problemas que pueden no estar relacionados con un modelo estocástico de un sistema real. Por ejemplo, en el Capítulo \ref{monte-carlo} se tratarán métodos de integración y optimización Monte Carlo.

\hypertarget{ealbum}{%
\subsection{Ejemplo}\label{ealbum}}

Supongamos que nos regalan un álbum con \(n = 75\) cromos, que se venden sobres con \(m = 6\) cromos por 0.8€, y que estamos interesados en el número de sobres que hay que comprar para completar la colección, por ejemplo en su valor medio.

Podemos aproximar la distribución del número de sobres para completar la colección a partir de \(nsim=1000\) simulaciones de coleccionistas de cromos:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Parámetros}
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{75} \CommentTok{\# Número total de cromos}
\NormalTok{m }\OtherTok{\textless{}{-}} \DecValTok{6}  \CommentTok{\# Número de cromos en cada sobre}
\NormalTok{repe }\OtherTok{\textless{}{-}} \ConstantTok{TRUE} \CommentTok{\# Repetición de cromos en cada sobre}
\CommentTok{\# Número de simulaciones}
\NormalTok{nsim }\OtherTok{\textless{}{-}} \DecValTok{1000}
\CommentTok{\# Resultados simulación}
\NormalTok{nsobres }\OtherTok{\textless{}{-}} \FunctionTok{numeric}\NormalTok{(nsim)}
\CommentTok{\# evol \textless{}{-} vector("list", nsim)}
\CommentTok{\# Fijar semilla}
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\CommentTok{\# Bucle simulación}
\ControlFlowTok{for}\NormalTok{ (isim }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\NormalTok{nsim) \{}
  \CommentTok{\# seed \textless{}{-} .Random.seed    \# .Random.seed \textless{}{-} seed}
\NormalTok{  album }\OtherTok{\textless{}{-}} \FunctionTok{logical}\NormalTok{(n)}
\NormalTok{  i }\OtherTok{\textless{}{-}} \DecValTok{0} \CommentTok{\# Número de sobres}
  \ControlFlowTok{while}\NormalTok{(}\FunctionTok{sum}\NormalTok{(album) }\SpecialCharTok{\textless{}}\NormalTok{ n) \{}
\NormalTok{    i }\OtherTok{\textless{}{-}}\NormalTok{ i }\SpecialCharTok{+} \DecValTok{1}
\NormalTok{    album[}\FunctionTok{sample}\NormalTok{(n,m, }\AttributeTok{replace =}\NormalTok{ repe)] }\OtherTok{\textless{}{-}} \ConstantTok{TRUE}
\NormalTok{  \}}
\NormalTok{  nsobres[isim] }\OtherTok{\textless{}{-}}\NormalTok{ i}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Distribución del número de sobres para completar la colección
(aproximada por simulación):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{hist}\NormalTok{(nsobres, }\AttributeTok{breaks =} \StringTok{"FD"}\NormalTok{, }\AttributeTok{freq =} \ConstantTok{FALSE}\NormalTok{,}
     \AttributeTok{main =} \StringTok{""}\NormalTok{, }\AttributeTok{xlab =} \StringTok{"Número de sobres"}\NormalTok{)}
\FunctionTok{lines}\NormalTok{(}\FunctionTok{density}\NormalTok{(nsobres))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{01-Introduccion_files/figure-latex/unnamed-chunk-3-1} \end{center}

Aproximación por simulación del número medio de sobres para completar la colección:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sol }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(nsobres)}
\NormalTok{sol}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 61.775
\end{verbatim}

Número mínimo de sobres para asegurar de que se completa la colección con una probabilidad del 95\%:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nmin }\OtherTok{\textless{}{-}} \FunctionTok{quantile}\NormalTok{(nsobres, }\AttributeTok{probs =} \FloatTok{0.95}\NormalTok{)}
\FunctionTok{ceiling}\NormalTok{(nmin)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 95% 
##  92
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Reserva de dinero para poder completar la colección el 95\% de las veces:}
\FunctionTok{ceiling}\NormalTok{(nmin)}\SpecialCharTok{*}\FloatTok{0.8}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  95% 
## 73.6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{hist}\NormalTok{(nsobres, }\AttributeTok{breaks =} \StringTok{"FD"}\NormalTok{, }\AttributeTok{freq =} \ConstantTok{FALSE}\NormalTok{,}
     \AttributeTok{main =} \StringTok{""}\NormalTok{, }\AttributeTok{xlab =} \StringTok{"Número de sobres"}\NormalTok{)}
\FunctionTok{lines}\NormalTok{(}\FunctionTok{density}\NormalTok{(nsobres))}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{v =}\NormalTok{ sol)}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{v =}\NormalTok{ nmin, }\AttributeTok{lty =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{01-Introduccion_files/figure-latex/unnamed-chunk-6-1} \end{center}

Por supuesto, la distribución del gasto necesario para completar la colección es esta misma reescalada.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{res }\OtherTok{\textless{}{-}}\NormalTok{ simres}\SpecialCharTok{::}\FunctionTok{mc.plot}\NormalTok{(nsobres}\SpecialCharTok{*}\FloatTok{0.8}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{01-Introduccion_files/figure-latex/unnamed-chunk-7-1} \end{center}

Aproximación del gasto medio:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{res}\SpecialCharTok{$}\NormalTok{approx  }\CommentTok{\# sol*0.8}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 49.42
\end{verbatim}

En el Ejercicio \ref{exr:album} se propone modificar este código para obtener información adicional sobre la evolución del número de cromos distintos dependiendo de los sobres comprados por un coleccionista.

\hypertarget{ventajas-e-inconvenientes-de-la-simulaciuxf3n}{%
\subsection{Ventajas e inconvenientes de la simulación}\label{ventajas-e-inconvenientes-de-la-simulaciuxf3n}}

Ventajas (Shannon, 1975):

\begin{itemize}
\item
  Cuando la resolución analítica no puede llevarse a cabo.
\item
  Cuando existen medios de resolver analíticamente el problema
  pero dicha resolución es complicada y costosa
  (o solo proporciona una solución aproximada).
\item
  Si se desea experimentar antes de que exista el sistema
  (pruebas para la construcción de un sistema).
\item
  Cuando es imposible experimentar sobre el sistema real
  por ser dicha experimentación destructiva.
\item
  En ocasiones en las que la experimentación sobre el sistema es
  posible pero no ética.
\item
  En sistemas que evolucionan muy lentamente en el tiempo.
\end{itemize}

El principal incoveniente puede ser el tiempo de computación necesario, aunque gracias a la gran potencia de cálculo de los computadores actuales, se puede obtener rápidamente una solución aproximada en la mayor parte de los problemas susceptibles de ser modelizados.
Además siempre están presentes los posibles problemas debidos a emplear un modelo:

\begin{itemize}
\item
  La construcción de un buen modelo puede ser una tarea muy costosa
  (compleja, laboriosa y requerir mucho tiempo;
  e.g.~modelos climáticos).
\item
  Frecuentemente el modelo omite variables o relaciones importantes entre ellas
  (los resultados pueden no ser válidos para el sistema real).
\item
  Resulta difícil conocer la precisión del modelo formulado.
\end{itemize}

Otro problema de la simulación es que se obtienen resultados para unos valores concretos de los parámetros del modelo, por lo que en principio
resultaría complicado extrapolar las conclusiones a otras situaciones.

\hypertarget{aplicaciones-de-la-simulaciuxf3n}{%
\subsection{Aplicaciones de la simulación}\label{aplicaciones-de-la-simulaciuxf3n}}

La simulación resulta de utilidad en multitud de contextos diferentes.
Los principales campos de aplicación son:

\begin{itemize}
\item
  Estadística:

  \begin{itemize}
  \item
    Muestreo, remuestreo\ldots{}
  \item
    Aproximación de distribuciones (de estadísticos, estimadores\ldots)
  \item
    Realización de contrastes, intervalos de confianza\ldots{}
  \item
    Comparación de estimadores, contrastes\ldots{}
  \item
    Validación teoría (distribución asintótica\ldots)
  \item
    Inferencia Bayesiana
  \end{itemize}
\item
  Optimización: Algoritmos genéticos, temple simulado\ldots{}
\item
  Análisis numérico: Aproximación de integrales, resolución de ecuaciones\ldots{}
\item
  Computación: Diseño, verificación y validación de algoritmos\ldots{}
\item
  Criptografía: Protocolos de comunicación segura\ldots{}
\item
  Física: Simulación de fenómenos naturales\ldots{}
\end{itemize}

En los capítulos \ref{aplic-inf} y \ref{monte-carlo} nos centraremos en algunas de las aplicaciones de utilidad en Estadística.

\hypertarget{tipos-de-nuxfameros-aleatorios}{%
\section{Tipos de números aleatorios}\label{tipos-de-nuxfameros-aleatorios}}

El primer requisito para poder realizar simulación estocástica sería disponer de números aleatorios.
Se distingue entre tres tipos de secuencias:

\begin{itemize}
\item
  \emph{números aleatorios puros} (\emph{true random}): se caracteriza porque no existe ninguna regla o plan que nos permita conocer sus valores.
\item
  \emph{números pseudo-aleatorios}: simulan realizaciones de una variable aleatoria (uniforme),
\item
  \emph{números cuasi-aleatorios}: secuencias deterministas con una distribución más regular en el rango considerado.
\end{itemize}

\hypertarget{nuxfameros-aleatorios-puros}{%
\subsection{Números aleatorios puros}\label{nuxfameros-aleatorios-puros}}

Normalmente son obtenidos por procesos físicos (loterías, ruletas, ruidos\ldots) y, hasta hace una décadas, se almacenaban en \emph{tablas de dígitos aleatorios}.
Por ejemplo, en 1955 la Corporación RAND publicó el libro \href{https://www.rand.org/pubs/monograph_reports/MR1418.html}{\emph{A Million Random Digits with 100,000 Normal Deviates}} que contenía números aleatorios generados mediante una ruleta electrónica conectada a una computadora (ver Figura \ref{fig:randbook}).

\begin{figure}[!htb]

{\centering \includegraphics[width=0.3\linewidth]{images/RAND} 

}

\caption{Líneas 10580-10594, columnas 21-40, del libro *A Million Random Digits with 100,000 Normal Deviates*.}\label{fig:randbook}
\end{figure}

El procedimiento que se utilizaba para seleccionar de una tabla, de forma manual, números aleatorios
en un rango de 1 a \emph{m} era el siguiente:

\begin{itemize}
\item
  Se selecciona al azar un punto de inicio en la tabla
  y la dirección que se seguirá.
\item
  Se agrupan los dígitos de forma que ``cubran'' el valor de \emph{m}.
\item
  Se va avanzado en la dirección elegida, seleccionando los valores menores o iguales que \emph{m} y descartando el resto.
\end{itemize}

Hoy en día están disponibles generadores de números aleatorios ``online'', por ejemplo:

\begin{itemize}
\item
  \href{http://www.random.org/integers}{RANDOM.ORG}: ruido atmosférico
  (ver paquete \texttt{random} en R).
\item
  \href{http://www.fourmilab.ch/hotbits}{HotBits}: desintegración radiactiva.
\end{itemize}

Aunque para un uso profesional es recomendable emplear generadores implementados mediante hardware:

\begin{itemize}
\item
  \href{http://software.intel.com/en-us/articles/intel-digital-random-number-generator-drng-software-implementation-guide}{Intel Digital Random Number Generator}
\item
  \href{https://rbridge.inlab.net/manual/trngs}{An Overview of Hardware based True Random Number Generators}
\end{itemize}

Sus principales aplicaciones hoy en día son en criptografía y juegos de azar, donde resulta especialmente importante su impredecibilidad.

El uso de números aleatorios puros presenta dos grandes incovenientes.
El principal para su aplicación en el campo de la Estadística (y en otros casos) es que los valores generados deberían ser independientes e idénticamente distribuidos con distribución conocida, algo que resulta difícil (o imposible) de garantizar.
Siempre está presente la posible aparición de sesgos, principalmente debidos a fallos del sistema o interferencias.
Por ejemplo, en el caso de la máquina RAND, fallos mecánicos en el sistema de grabación de los datos causaron problemas de aleatoriedad (Hacking, 1965, p.~129).

El otro inconveniente estaría relacionado con su reproducibilidad, por lo que habría que almacenarlos en tablas si se quieren volver a reproducir los resultados.
A partir de la década de 1960, al disponer de computadoras de mayor velocidad, empezó a resultar más eficiente generar valores mediante software en lugar de leerlos de tablas.

\hypertarget{nuxfameros-cuasi-aleatorios}{%
\subsection{Números cuasi-aleatorios}\label{nuxfameros-cuasi-aleatorios}}

Algunos problemas, como la integración numérica (en el Capítulo \ref{monte-carlo} se tratarán métodos de integración Monte Carlo), no dependen realmente de la aleatoriedad de la secuencia. Para evitar generaciones poco probables, se puede recurrir a secuencias cuasi-aleatorias, también denominadas \emph{sucesiones de baja discrepancia} (hablaríamos entonces de métodos cuasi-Monte Carlo). La idea sería que la proporción de valores en una región cualquiera sea siempre aproximadamente proporcional a la medida de la región (como sucedería en media con la distribución uniforme, aunque no necesariamente para una realización concreta).

Por ejemplo, el paquete \href{https://CRAN.R-project.org/package=randtoolbox}{\texttt{randtoolbox}} de R implementa métodos para la generación de secuencias cuasi-aleatorias (ver Figura \ref{fig:randtoolbox}).

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(randtoolbox)}
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{2000}
\NormalTok{par.old }\OtherTok{\textless{}{-}} \FunctionTok{par}\NormalTok{( }\AttributeTok{mfrow=}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{))}
\FunctionTok{plot}\NormalTok{(}\FunctionTok{halton}\NormalTok{(n, }\AttributeTok{dim =} \DecValTok{2}\NormalTok{), }\AttributeTok{xlab =} \StringTok{\textquotesingle{}x1\textquotesingle{}}\NormalTok{, }\AttributeTok{ylab =} \StringTok{\textquotesingle{}x2\textquotesingle{}}\NormalTok{)}
\FunctionTok{plot}\NormalTok{(}\FunctionTok{sobol}\NormalTok{(n, }\AttributeTok{dim =} \DecValTok{2}\NormalTok{), }\AttributeTok{xlab =} \StringTok{\textquotesingle{}x1\textquotesingle{}}\NormalTok{, }\AttributeTok{ylab =} \StringTok{\textquotesingle{}x2\textquotesingle{}}\NormalTok{)}
\FunctionTok{plot}\NormalTok{(}\FunctionTok{torus}\NormalTok{(n, }\AttributeTok{dim =} \DecValTok{2}\NormalTok{), }\AttributeTok{xlab =} \StringTok{\textquotesingle{}x1\textquotesingle{}}\NormalTok{, }\AttributeTok{ylab =} \StringTok{\textquotesingle{}x2\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[!htb]

{\centering \includegraphics[width=1\linewidth]{01-Introduccion_files/figure-latex/randtoolbox-1} 

}

\caption{Secuencias cuasi-aleatorias bidimensionales obtenidas con los métodos de Halton (izquierda), Sobol (centro) y Torus (derecha).}\label{fig:randtoolbox}
\end{figure}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{par}\NormalTok{(par.old)}
\end{Highlighting}
\end{Shaded}

En este libro sólo consideraremos los números pseudoaleatorios y por comodidad se eliminará el prefijo ``pseudo'' en algunos casos.

\hypertarget{nuxfameros-pseudo-aleatorios}{%
\subsection{Números pseudo-aleatorios}\label{nuxfameros-pseudo-aleatorios}}

La mayoría de los métodos de simulación se basan en la posibilidad de generar números pseudoaleatorios que imiten las propiedades de valores independientes de una distribución \(\mathcal{U}(0,1)\), es decir, que imiten las propiedades de una muestra aleatoria simple\footnote{Aunque hay que distinguir entre secuencia y muestra. En un problema de inferencia, en principio estamos interesados en una característica desconocida de la población. En cambio, en un problema de simulación ``la población'' es el modelo y lo conocemos por completo (no obstante el problema de simulación puede surgir como solución de un problema de inferencia).}.

El procedimiento habitual para obtener estas secuencias es emplear un algoritmo recursivo denominado \emph{generador}:

\[x_{i} = f\left( x_{i-1}, x_{i-2}, \cdots, x_{i-k}\right)\]

donde:

\begin{itemize}
\item
  \(k\) es el orden del generador.
\item
  \(\left( x_{0},x_{1},\cdots,x_{k-1}\right)\) es la \emph{semilla}
  (estado inicial).
\end{itemize}

El \emph{periodo} o \emph{longitud del ciclo} es la longitud de la secuencia antes de que vuelva a repetirse. Lo denotaremos por \(p\).

Los números de la sucesión son predecibles, conociendo el algoritmo y la semilla.
Sin embargo, si no se conociesen, \emph{no se debería poder distinguir} una serie de números pseudoaleatorios \emph{de una sucesión de números verdaderamente aleatoria} (utilizando recursos computacionales razonables).
En caso contrario esta predecibilidad puede dar lugar a serios
problemas (e.g.~\url{http://eprint.iacr.org/2007/419}).

Como regla general, por lo menos mientras se está desarrollando un
programa, interesa \emph{fijar la semilla de aleatorización}.

\begin{itemize}
\item
  Permite la reproducibilidad de los resultados.
\item
  Facilita la depuración del código.
\end{itemize}

Todo generador de números pseudoaleatorios mínimamente aceptable debe comportarse como si proporcionase muestras genuinas de datos independientes de una \(\mathcal{U}(0,1)\).
Otras propiedades de interés son:

\begin{itemize}
\item
  Reproducibilidad a partir de la semilla.
\item
  Periodo suficientemente largo.
\item
  Eficiencia (rapidez y requerimientos de memoria).
\item
  Portabilidad.
\item
  Generación de sub-secuencias (computación en paralelo).
\item
  Parsimonia.
\end{itemize}

Es importante asegurarse de que el generador empleado es adecuado:

\begin{quote}
``Random numbers should not be generated with a method chosen at random.''

--- Knuth, D.E. (TAOCP, 2002)
\end{quote}

Se dispone de una gran cantidad de algoritmos.
Los primeros intentos (cuadrados medios, método de Lehmer\ldots) resultaron infructuosos, pero al poco tiempo ya se propusieron métodos que podían ser ampliamente utilizados (estableciendo adecuadamente sus parámetros).
Entre ellas podríamos destacar:

\begin{itemize}
\item
  Generadores congruenciales.
\item
  Registros desfasados.
\item
  Combinaciones de distintos algoritmos.
\end{itemize}

La recomendación sería emplear un algoritmo conocido y que haya sido estudiado en profundidad (por ejemplo el generador \emph{Mersenne-Twister} empleado por defecto en R, propuesto por Matsumoto y Nishimura, 1998).
Además, sería recomendable utilizar alguna de las implementaciones disponibles en múltiples librerías, por ejemplo:

\begin{itemize}
\item
  GNU Scientific Library (GSL):
  \href{http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Generation.html}{http://www.gnu.org/software/gsl/manual}
\item
  StatLib: \url{http://lib.stat.cmu.edu}
\item
  Numerical recipes: \url{http://www.nrbook.com/nr3}
\item
  UNU.RAN (paquete \texttt{Runuran}):
  \url{http://statmath.wu.ac.at/unuran}
\end{itemize}

En este libro nos centraremos en los generadores congruenciales, descritos en la Sección \ref{gen-cong}.
Estos métodos son muy simples, aunque con las opciones adecuadas podrían ser utilizados en pequeños estudios de simulación. Sin embargo, su principal interés es que constituyen la base de los generadores avanzados habitualmente considerados.

\hypertarget{rrng}{%
\section{Números aleatorios en R}\label{rrng}}

La generación de números pseudoaleatorios en R es una de las mejores
disponibles en paquetes estadísticos.
Entre las herramientas implementadas en el paquete base de R podemos destacar:

\begin{itemize}
\item
  \texttt{set.seed(entero)}: permite establecer la semilla (y el generador).
\item
  \texttt{RNGkind()}: selecciona el generador.
\item
  \texttt{rdistribución(n,...):} genera valores aleatorios de la correspondiente distribución.
  Por ejemplo, \texttt{runif(n,\ min\ =\ 0,\ max\ =\ 1)}, generaría \texttt{n} valores de una uniforme. Se puede acceder al listado completo de las funciones disponibles en el paquete \texttt{stats} mediante el comando \texttt{?distributions}.
\item
  \texttt{sample()}: genera muestras aleatorias de variables discretas y permutaciones (se tratará en el Capítulo \ref{discretas}).
\item
  \texttt{simulate()}: genera realizaciones de la respuesta de un modelo ajustado.
\end{itemize}

Además están disponibles otros paquetes que implementan distribuciones adicionales (ver \href{https://cran.r-project.org/view=Distributions}{CRAN Task View: Probability Distributions}).
Entre ellos podríamos destacar los paquetes \href{http://distr.r-forge.r-project.org}{\texttt{distr}} (clases S4; con extensiones en otros paquetes) y \href{https://alan-turing-institute.github.io/distr6/index.html}{\texttt{distr6}} (clases R6).

La semilla se almacena (en \texttt{globalenv}) en \texttt{.Random.seed}; es un vector
de enteros cuya dimensión depende del tipo de generador:

\begin{itemize}
\item
  No debe ser modificado manualmente; se guarda con el entorno de trabajo (por ejemplo, si se guarda al terminar la sesión en un fichero \emph{.RData}, se restaurará la semilla al iniciar una nueva sesión y podremos continuar con las simulaciones).
\item
  Si no se especifica con \texttt{set.seed} (o no existe) se genera a partir del reloj del sistema.
\item
  Puede ser recomendable almacenarla antes de generar simulaciones, e.g.~\texttt{seed\ \textless{}-\ .Random.seed}.
  Esto permite reproducir los resultados y facilita la depuración de posibles errores.
\end{itemize}

En la mayoría de los ejemplos de este libro se generan todos los valores de una vez,
se guardan y se procesan vectorialmente (normalmente empleando la función \texttt{apply}).
En problemas mas complejos, en los que no es necesario almacenar todas las simulaciones,
puede ser preferible emplear un bucle para generar y procesar cada simulación iterativamente.
Por ejemplo podríamos emplear el siguiente esquema:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Fijar semilla}
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\ControlFlowTok{for}\NormalTok{ (isim }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\NormalTok{nsim) \{}
\NormalTok{  seed }\OtherTok{\textless{}{-}}\NormalTok{ .Random.seed}
  \CommentTok{\# Si se produce un error, podremos depurarlo ejecutando:}
  \CommentTok{\#  .Random.seed \textless{}{-} seed}
\NormalTok{  ...}
  \CommentTok{\# Generar valores pseudoaleatorios}
\NormalTok{  ...}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

o alternativamente fijar la semilla en cada iteración, por ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ (isim }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\NormalTok{nsim) \{}
  \FunctionTok{set.seed}\NormalTok{(isim)}
\NormalTok{  ...}
  \CommentTok{\# Generar valores pseudoaleatorios}
\NormalTok{  ...}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{oprrng}{%
\subsection{Opciones}\label{oprrng}}

Normalmente no nos va a interesar cambiar las opciones por defecto de R para la generación de números pseudoaleatorios.
Para establecer estas opciones podemos emplear los argumentos \texttt{kind\ =\ NULL}, \texttt{normal.kind\ =\ NULL} y \texttt{sample.kind\ =\ NULL} en las funciones \texttt{RNGkind()} o \texttt{set.seed()}.
A continuación se muestran las distintas opciones (resaltando en negrita los valores por defecto):

\begin{itemize}
\item
  \texttt{kind} especifica el generador pseudoaleatorio (uniforme):

  \begin{itemize}
  \item
    ``Wichmann-Hill'': Ciclo \(6.9536\times10^{12}\)
  \item
    ``Marsaglia-Multicarry'': Ciclo mayor de \(2^{60}\)
  \item
    ``Super-Duper'': Ciclo aprox. \(4.6\times10^{18}\) (S-PLUS)
  \item
    \textbf{``Mersenne-Twister''}: Ciclo \(2^{19937}-1\) y equidistribution
    en 623 dimensiones.
  \item
    ``Knuth-TAOCP-2002'': Ciclo aprox. \(2^{129}\).
  \item
    ``Knuth-TAOCP''
  \item
    ``user-supplied'': permite emplear generadores adicionales.
  \end{itemize}
\item
  \texttt{normal.kind} selecciona el método de generación de normales
  (se tratará más adelante):
  ``Kinderman-Ramage'', ``Buggy Kinderman-Ramage'',
  ``Ahrens-Dieter'', ``Box-Muller'', \textbf{``Inversion''} , o ``user-supplied''.
\item
  \texttt{sample.kind} selecciona el método de generación de uniformes discretas (el empleado por la función \texttt{sample()}, que cambió ligeramente\footnote{Para evitar problemas de redondeo con tamaños extremadamente grandes; ver bug \href{https://bugs.r-project.org/bugzilla3/show_bug.cgi?id=17494}{PR\#17494}.} a partir de la versión 3.6.0 de R): ``Rounding'' (versión anterior a 3.6.0) o \textbf{``Rejection''}.
\end{itemize}

Estas opciones están codificadas (con índices comenzando en 0) en el primer componente de la semilla:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{.Random.seed[}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 10403
\end{verbatim}

Los dos últimos dígitos se corresponden con el generador, las centenas con el método de generación de normales y las decenas de millar con el método uniforme discreto.

\hypertarget{paquetes-de-r}{%
\subsection{Paquetes de R}\label{paquetes-de-r}}

Otros paquetes de R que pueden ser de interés:

\begin{itemize}
\item
  \texttt{setRNG} contiene herramientas que facilitan operar con la semilla
  (dentro de funciones,\ldots).
\item
  \texttt{random} permite la descarga de números ``true random'' desde \href{https://www.random.org}{RANDOM.ORG}.
\item
  \texttt{randtoolbox} implementa generadores más recientes (\texttt{rngWELL}) y
  generación de secuencias cuasi-aleatorias.
\item
  \texttt{RDieHarder} implementa diversos contrastes para el análisis de la
  calidad de un generador y varios generadores.
\item
  \href{http://statmath.wu.ac.at/unuran}{\texttt{Runuran}} interfaz para la librería UNU.RAN para la
  generación (automática) de variables aleatorias no uniformes (ver Hörmann et al., 2004).
\item
  \texttt{rsprng}, \texttt{rstream} y \texttt{rlecuyer} implementan la generación de múltiples
  secuencias (para programación paralela).
\item
  \texttt{gls}, \texttt{rngwell19937}, \texttt{randaes}, \texttt{SuppDists}, \texttt{lhs}, \texttt{mc2d},
  \texttt{fOptions}, \ldots{}
\end{itemize}

\hypertarget{tiempo-de-cpu}{%
\subsection{Tiempo de CPU}\label{tiempo-de-cpu}}

La velocidad del generador suele ser una característica importante (también medir los tiempos, de cada iteración y de cada procedimento, en estudios de simulación).
Para evaluar el rendimiento están disponibles en R distintas herramientas:

\begin{itemize}
\item
  \texttt{proc.time()}: permite obtener tiempo de computación real y de
  CPU.

\begin{verbatim}
tini <- proc.time()
# Código a evaluar
tiempo <- proc.time() - tini
\end{verbatim}
\item
  \texttt{system.time(expresión)}: muestra el tiempo de computación (real y
  de CPU) de expresión.
\end{itemize}

Por ejemplo, podríamos emplear las siguientes funciones para
ir midiendo los tiempos de CPU durante una simulación:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{CPUtimeini }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  .tiempo.ini }\OtherTok{\textless{}\textless{}{-}} \FunctionTok{proc.time}\NormalTok{()}
\NormalTok{  .tiempo.last }\OtherTok{\textless{}\textless{}{-}}\NormalTok{ .tiempo.ini}
\NormalTok{\}}

\NormalTok{CPUtimeprint }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  tmp }\OtherTok{\textless{}{-}} \FunctionTok{proc.time}\NormalTok{()}
  \FunctionTok{cat}\NormalTok{(}\StringTok{"Tiempo última operación:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
  \FunctionTok{print}\NormalTok{(tmp}\SpecialCharTok{{-}}\NormalTok{.tiempo.last)}
  \FunctionTok{cat}\NormalTok{(}\StringTok{"Tiempo total operación:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
  \FunctionTok{print}\NormalTok{(tmp}\SpecialCharTok{{-}}\NormalTok{.tiempo.ini)}
\NormalTok{  .tiempo.last }\OtherTok{\textless{}\textless{}{-}}\NormalTok{ tmp}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Llamando a \texttt{CPUtimeini()} donde se quiere empezar a contar,
y a \texttt{CPUtimeprint()} para imprimir el tiempo total
y el tiempo desde la última llamada a una de estas funciones.
Ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{funtest }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(n) }\FunctionTok{mad}\NormalTok{(}\FunctionTok{runif}\NormalTok{(n)) }
\FunctionTok{CPUtimeini}\NormalTok{()}
\NormalTok{result1 }\OtherTok{\textless{}{-}} \FunctionTok{funtest}\NormalTok{(}\DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{6}\NormalTok{)}
\FunctionTok{CPUtimeprint}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Tiempo última operación:
##    user  system elapsed 
##    0.46    0.07    0.59 
## Tiempo total operación:
##    user  system elapsed 
##    0.46    0.07    0.59
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{result2 }\OtherTok{\textless{}{-}} \FunctionTok{funtest}\NormalTok{(}\DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{3}\NormalTok{)}
\FunctionTok{CPUtimeprint}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Tiempo última operación:
##    user  system elapsed 
##    0.03    0.00    0.04 
## Tiempo total operación:
##    user  system elapsed 
##    0.49    0.07    0.63
\end{verbatim}

Hay diversos paquetes que implementan herramientas similares, por ejemplo:

\begin{itemize}
\item
  El paquete \texttt{tictoc}:

  \begin{itemize}
  \item
    \texttt{tic("mensaje")}: inicia el temporizador y almacena el tiempo de inicio junto con el mensaje en una pila.
  \item
    \texttt{toc()}: calcula el tiempo transcurrido desde la llamada correspondiente a \texttt{tic()}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tictoc)}
\DocumentationTok{\#\# Timing nested code}
\FunctionTok{tic}\NormalTok{(}\StringTok{"outer"}\NormalTok{)}
\NormalTok{   result1 }\OtherTok{\textless{}{-}} \FunctionTok{funtest}\NormalTok{(}\DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{6}\NormalTok{)}
   \FunctionTok{tic}\NormalTok{(}\StringTok{"middle"}\NormalTok{)}
\NormalTok{      result2 }\OtherTok{\textless{}{-}} \FunctionTok{funtest}\NormalTok{(}\DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{3}\NormalTok{)}
      \FunctionTok{tic}\NormalTok{(}\StringTok{"inner"}\NormalTok{)}
\NormalTok{         result3 }\OtherTok{\textless{}{-}} \FunctionTok{funtest}\NormalTok{(}\DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{)}
      \FunctionTok{toc}\NormalTok{() }\CommentTok{\# inner}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## inner: 0.02 sec elapsed
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
   \FunctionTok{toc}\NormalTok{() }\CommentTok{\# middle}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## middle: 0.03 sec elapsed
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{toc}\NormalTok{() }\CommentTok{\# outer}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## outer: 0.81 sec elapsed
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Timing in a loop and analyzing the results later using tic.log().}
\FunctionTok{tic.clearlog}\NormalTok{()}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{)}
\NormalTok{\{}
   \FunctionTok{tic}\NormalTok{(i)}
\NormalTok{   result }\OtherTok{\textless{}{-}} \FunctionTok{funtest}\NormalTok{(}\DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{4}\NormalTok{)}
   \FunctionTok{toc}\NormalTok{(}\AttributeTok{log =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{quiet =} \ConstantTok{TRUE}\NormalTok{)}
\NormalTok{\}}
\CommentTok{\# log.txt \textless{}{-} tic.log(format = TRUE)}
\CommentTok{\# log.lst \textless{}{-} tic.log(format = FALSE)}
\NormalTok{log.times }\OtherTok{\textless{}{-}} \FunctionTok{do.call}\NormalTok{(rbind.data.frame, }\FunctionTok{tic.log}\NormalTok{(}\AttributeTok{format =} \ConstantTok{FALSE}\NormalTok{))}
\FunctionTok{str}\NormalTok{(log.times)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'data.frame':    10 obs. of  3 variables:
##  $ tic: num  14.6 14.6 14.6 14.6 14.6 ...
##  $ toc: num  14.6 14.6 14.6 14.6 14.6 ...
##  $ msg: chr  "1" "2" "3" "4" ...
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tic.clearlog}\NormalTok{()}

\CommentTok{\# timings \textless{}{-} unlist(lapply(log.lst, function(x) x$toc {-} x$tic))}
\NormalTok{log.times}\SpecialCharTok{$}\NormalTok{timings }\OtherTok{\textless{}{-}} \FunctionTok{with}\NormalTok{(log.times, toc }\SpecialCharTok{{-}}\NormalTok{ tic)}
\FunctionTok{summary}\NormalTok{(log.times}\SpecialCharTok{$}\NormalTok{timings)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##   0.000   0.000   0.000   0.002   0.000   0.020
\end{verbatim}
  \end{itemize}
\item
  La función \href{https://rubenfcasal.github.io/simres/reference/cpu.time.html}{\texttt{cpu.time()}} del paquete \texttt{simres}:

  \begin{itemize}
  \item
    \texttt{cpu.time(restart\ =\ TRUE)}: inicia el temporizador y almacena el tiempo de inicio.
  \item
    \texttt{cpu.time()}: calcula el tiempo (real y de CPU) total (desde tiempo de inicio) y parcial (desde la última llamada a esta función).
  \end{itemize}
\end{itemize}

Hay que tener en cuenta que, por construcción, aunque se realicen en la mismas condiciones (en el mismo equipo), los tiempos de CPU en R pueden variar ``ligeramente'' entre ejecuciones.
Si se quieren estudiar tiempos de computación de forma más precisa, se recomendaría promediar los tiempos de varias ejecuciones.
Para ello se pueden emplear las herramientas del paquete \href{https://CRAN.R-project.org/package=microbenchmark}{\texttt{microbenchmark}}.
No obstante, para los fines de este libro no será necesaria tanta precisión.

Finalmente, si los tiempos de computación no fuesen asumibles, para identificar los cuellos de botella y mejorar el código para optimizar la velocidad, podríamos emplear la función \texttt{Rprof(fichero)}.
Esta función permite evaluar el rendimiento muestreando la pila en intervalos para determinar en que funciones se emplea el tiempo de computación.
Después de ejecutar el código, llamando a \texttt{Rprof(NULL)} se desactiva el muestreo y con \texttt{summaryRprof(fichero)} se muestran los resultados (para analizarlos puede resultar de utilidad el paquete \href{https://CRAN.R-project.org/package=proftools}{\texttt{proftools}}).

\hypertarget{ejercicios}{%
\section{Ejercicios}\label{ejercicios}}

\begin{exercise}
\protect\hypertarget{exr:simpi}{}{\label{exr:simpi} }
\end{exercise}

Sea \((X,Y)\) es un vector aleatorio con distribución uniforme en el
cuadrado \([-1,1]\times\lbrack-1,1]\) de área 4.

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\item
  Aproximar mediante simulación \(P\left(X + Y \leq 0 \right)\) y
  compararla con la probabilidad teórica (obtenida aplicando la
  regla de Laplace \(\frac{\text{área favorable}}{\text{área posible}}\)).
\item
  Aproximar el valor de \(\pi\) mediante simulación a partir de
  \(P\left( X^2 +Y^2 \leq 1 \right)\).
\end{enumerate}

Ver solución en Sección \ref{sol-simpi}.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{exercise}[Experimento de Bernoulli]
\protect\hypertarget{exr:bernoulli}{}{\label{exr:bernoulli} \iffalse (Experimento de Bernoulli) \fi{} }
\end{exercise}
Consideramos el experimento de Bernoulli consistente en el
lanzamiento de una moneda.

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\item
  Empleando la función \texttt{sample}, obtener 1000 simulaciones del
  lanzamiento de una moneda \texttt{(0\ =\ cruz,\ 1\ =\ cara)}, suponiendo que
  no está trucada. Aproximar la probabilidad de cara a partir de
  las simulaciones.
\item
  En R pueden generarse valores de la distribución de Bernoulli
  mediante la función \texttt{rbinom(nsim,\ size=1,\ prob)}. Generar un
  gráfico de lineas considerando en el eje \(X\) el número de
  lanzamientos (de 1 a 10000) y en el eje \(Y\) la frecuencia
  relativa del suceso cara (puede ser recomendable emplear la
  función \texttt{cumsum}).
\end{enumerate}

Ver solución en Sección \ref{sol-bernoulli}.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{exercise}[Simulación de un circuito]
\protect\hypertarget{exr:circuito}{}{\label{exr:circuito} \iffalse (Simulación de un circuito) \fi{} }
\end{exercise}
Simular el paso de corriente a través del siguiente circuito, donde
figuran las probabilidades de que pase corriente por cada uno de los
interruptores:

\begin{center}\includegraphics[width=0.5\linewidth]{images/circuito2} \end{center}

Considerar que cada interruptor es una variable aleatoria de Bernoulli independiente
para simular 1000 valores de cada una de ellas.

\begin{remark}
\iffalse{} {Nota: } \fi{}R maneja internamente los valores lógicos como 1 (\texttt{TRUE}) y 0 (\texttt{FALSE}).
Recíprocamente, cualquier número puede ser tratado como lógico (al estilo de C).
El entero 0 es equivalente a \texttt{FALSE} y cualquier entero distinto de 0 a \texttt{TRUE}.
\end{remark}

Ver solución en Sección \ref{sol-circuito}.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{exercise}[El problema del Caballero de Méré]
\protect\hypertarget{exr:mere}{}{\label{exr:mere} \iffalse (El problema del Caballero de Méré) \fi{} }
\end{exercise}
En 1651, el Caballero de Méré le planteó a Pascal una pregunta
relacionada con las apuestas y los juegos de azar: ¿es ventajoso
apostar a que en cuatro lanzamientos de un dado se obtiene al menos
un seis? Este problema generó una fructífera correspondencia entre
Pascal y Fermat que se considera, simbólicamente, como el nacimiento
del Cálculo de Probabilidades.

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\item
  Escribir una función que simule el lanzamiento de \(n\) dados. El
  parámetro de entrada es el número de lanzamientos \(n\), que toma
  el valor 4 por defecto, y la salida debe ser \texttt{TRUE} si se
  obtiene al menos un 6 y \texttt{FALSE} en caso contrario.
\item
  Utilizar la función anterior para simular \(nsim=10000\) jugadas
  de este juego y calcular la proporción de veces que se gana la
  apuesta (obtener al menos un 6 en \(n\) lanzamientos), usando
  \(n=4\). Comparar el resultado con la probabilidad teórica
  \(1-(5/6)^{n}\).
\end{enumerate}

Ver solución en Sección \ref{sol-mere}.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{exercise}[variación del problema del coleccionista (cadena de Markov)]
\protect\hypertarget{exr:album}{}{\label{exr:album} \iffalse (variación del problema del coleccionista (cadena de Markov)) \fi{} }
\end{exercise}

Continuando con el ejemplo de la Sección \ref{ealbum}
(álbum con \(n = 75\) cromos y sobres con \(m = 6\)). A partir de \(nsim=2000\) simulaciones de coleccionistas de cromos, aproximar por simulación la evolución del proceso de compra de un coleccionista (número de cromos distintos dependiendo de los sobres comprados).

Ver solución en Sección \ref{sol-album}.

\hypertarget{gen-pseudo}{%
\chapter{Generación de números pseudoaleatorios}\label{gen-pseudo}}

Como ya se comentó, los distintos métodos de simulación requieren disponer de secuencias de números pseudoaleatorios que imiten las propiedades de generaciones independientes de una distribución \(\mathcal{U}(0,1)\).
En primer lugar nos centraremos en el caso de los generadores congruenciales. A pesar de su simplicidad, podrían ser adecuados en muchos casos y constituyen la base de los generadores avanzados habitualmente considerados.
Posteriormente se dará una visión de las diferentes herramientas para estudiar la calidad de un generador de números pseudoaleatorios.

\hypertarget{gen-cong}{%
\section{Generadores congruenciales lineales}\label{gen-cong}}

En los generadores congruenciales lineales se considera una combinación lineal de los últimos \(k\) enteros generados y se calcula su resto al dividir por un entero fijo \(m\).
En el método congruencial simple (de orden \(k = 1\)), partiendo de una semilla inicial \(x_0\), el algoritmo secuencial es el siguiente:
\[\begin{aligned}
x_{i}  & = (ax_{i-1}+c) \bmod m \\
u_{i}  & = \dfrac{x_{i}}{m} \\
i  & =1,2,\ldots
\end{aligned}\]
donde \(a\) (\emph{multiplicador}), \(c\) (\emph{incremento}) y \(m\) (\emph{módulo}) son enteros positivos\footnote{Se supone además que \(a\), \(c\) y \(x_0\) son menores que \(m\), ya que, dadas las propiedades algebraicas de la suma y el producto en el conjunto de clases de resto módulo \(m\) (que es un anillo), cualquier otra elección de valores mayores o iguales que \(m\) tiene un equivalente verificando esta restricción.} fijados de antemano (los parámetros de este generador). Si \(c=0\) el generador se denomina congruencial \emph{multiplicativo} (Lehmer, 1951) y en caso contrario se dice que es \emph{mixto} (Rotenburg, 1960).

Obviamente los parámetros y la semilla determinan los valores generados, que también se pueden obtener de forma no recursiva:
\[x_{i}=\left( a^{i}x_0+c\frac{a^{i}-1}{a-1}\right) \bmod m\]

Este método está implementado\footnote{Aunque de forma no muy eficiente. Para evitar problemas computacionales, se recomienda realizar el cálculo de los valores empleando el método de Schrage (ver Bratley \emph{et al.}, 1987; L'Ecuyer, 1988).} en la función \texttt{rlcg()} del paquete \href{https://rubenfcasal.github.io/simres}{\texttt{simres}}, imitando el funcionamiento del generador uniforme de R (ver también \texttt{simres::rng()}; fichero \href{R/rng.R}{\emph{rng.R}}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{simres}\SpecialCharTok{::}\NormalTok{rlcg}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## function(n, seed = as.numeric(Sys.time()), a = 7^5, c = 0, m = 2^31 - 1) {
##   u <- numeric(n)
##   for(i in 1:n) {
##     seed <- (a * seed + c) %% m
##     u[i] <- seed/m # (seed + 1)/(m + 1)
##   }
##   # Almacenar semilla y parámetros
##   assign(".rng", list(seed = seed, type = "lcg",
##           parameters = list(a = a, c = c, m = m)), envir = globalenv())
##   # .rng <<- list(seed = seed, type = "lcg", parameters = list(a = a, c = c, m = m))
##   # Para continuar con semilla y parámetros:
##   #   with(.rng, rlcg(n, seed, parameters$a, parameters$c, parameters$m))
##   # Devolver valores
##   return(u)
## }
## <bytecode: 0x0000000039034278>
## <environment: namespace:simres>
\end{verbatim}

Ejemplos de parámetros:

\begin{itemize}
\item
  \(c=0\), \(a=2^{16}+3=65539\) y \(m=2^{31}\), generador \emph{RANDU} de IBM
  (\textbf{no recomendable}).
\item
  \(c=0\), \(a=7^{5}=16807\) y \(m=2^{31}-1\) (primo de Mersenne), Park y Miller (1988)
  \emph{minimal standar}, empleado por las librerías IMSL y NAG.
\item
  \(c=0\), \(a=48271\) y \(m=2^{31}-1\) actualización del \emph{minimal standar}
  propuesta por Park, Miller y Stockmeyer (1993).
\end{itemize}

A pesar de su simplicidad, una adecuada elección de los parámetros permite obtener de manera eficiente secuencias de números ``aparentemente'' i.i.d. \(\mathcal{U}(0,1)\).
Durante los primeros años, el procedimiento habitual consistía en escoger \(m\) de forma que se pudiera realizar eficientemente la operación del módulo, aprovechando la arquitectura del ordenador (por ejemplo \(m = 2^{31}\) si se emplean enteros con signo de 32 bits).
Posteriormente se seleccionaban \(c\) y \(a\) de forma que el período \(p\) fuese lo más largo posible (o suficientemente largo), empleando los resultados mostrados a continuación.

\begin{theorem}[Hull y Dobell, 1962]
\protect\hypertarget{thm:hull-dobell}{}{\label{thm:hull-dobell} \iffalse (Hull y Dobell, 1962) \fi{} }
Un generador congruencial tiene período máximo (\(p=m\)) si y solo si:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \(c\) y \(m\) son primos relativos (i.e.~\(m.c.d.(c, m) = 1\)).
\item
  \(a-1\) es múltiplo de todos los factores primos de \(m\) (i.e.
  \(a \equiv 1 \bmod q\), para todo \(q\) factor primo de \(m\)).
\item
  Si \(m\) es múltiplo de \(4\), entonces \(a-1\) también lo ha de
  ser (i.e.~\(m \equiv 0 \bmod 4\Rightarrow a \equiv 1 \bmod 4\)).
\end{enumerate}
\end{theorem}

Algunas consecuencias:

\begin{itemize}
\item
  Si \(m\) primo, \(p=m\) si y solo si \(a=1\).
\item
  Un generador multiplicativo no cumple la condición 1 (\(m.c.d.(0, m)=m\)).
\end{itemize}

\begin{theorem}
\protect\hypertarget{thm:unnamed-chunk-3}{}{\label{thm:unnamed-chunk-3} }
Un generador multiplicativo tiene período máximo (\(p=m-1\)) si:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \(m\) es primo.
\item
  \(a\) es una raiz primitiva de \(m\) (i.e.~el menor entero \(q\) tal
  que \(a^{q}=1 \bmod m\) es \(q=m-1\)).
\end{enumerate}
\end{theorem}

Además de preocuparse de la longitud del ciclo, las secuencias generadas deben aparentar muestras i.i.d. \(\mathcal{U}(0,1)\).

Uno de los principales problemas es que los valores generados pueden mostrar una clara estructura reticular.
Este es el caso por ejemplo del generador RANDU de IBM muy empleado en la década de los 70 (ver Figura \ref{fig:randu})\footnote{Alternativamente se podría utilizar la función \texttt{plot3d} del paquete \texttt{rgl}, y rotar la figura (pulsando con el ratón) para ver los hiperplanos:
  \texttt{rgl::plot3d(xyz)}}.
Por ejemplo, el conjunto de datos \texttt{randu} contiene 400 tripletas de números sucesivos obtenidos con la implementación de VAX/VMS 1.5 (1977).

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(simres)}
\FunctionTok{system.time}\NormalTok{(u }\OtherTok{\textless{}{-}} \FunctionTok{rlcg}\NormalTok{(}\AttributeTok{n =} \DecValTok{9999}\NormalTok{, }
          \AttributeTok{seed =} \DecValTok{543210}\NormalTok{, }\AttributeTok{a =} \DecValTok{2}\SpecialCharTok{\^{}}\DecValTok{16} \SpecialCharTok{+} \DecValTok{3}\NormalTok{, }\AttributeTok{c =} \DecValTok{0}\NormalTok{, }\AttributeTok{m =} \DecValTok{2}\SpecialCharTok{\^{}}\DecValTok{31}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    user  system elapsed 
##       0       0       0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# xyz \textless{}{-} matrix(u, ncol = 3, byrow = TRUE)}
\NormalTok{xyz }\OtherTok{\textless{}{-}}\NormalTok{ stats}\SpecialCharTok{::}\FunctionTok{embed}\NormalTok{(u, }\DecValTok{3}\NormalTok{)}
\FunctionTok{library}\NormalTok{(plot3D)}
\CommentTok{\# points3D(xyz[,1], xyz[,2], xyz[,3], colvar = NULL, phi = 60, }
\CommentTok{\#          theta = {-}50, pch = 21, cex = 0.2)}
\FunctionTok{points3D}\NormalTok{(xyz[,}\DecValTok{3}\NormalTok{], xyz[,}\DecValTok{2}\NormalTok{], xyz[,}\DecValTok{1}\NormalTok{], }\AttributeTok{colvar =} \ConstantTok{NULL}\NormalTok{, }\AttributeTok{phi =} \DecValTok{60}\NormalTok{, }
         \AttributeTok{theta =} \SpecialCharTok{{-}}\DecValTok{50}\NormalTok{, }\AttributeTok{pch =} \DecValTok{21}\NormalTok{, }\AttributeTok{cex =} \FloatTok{0.2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[!htb]

{\centering \includegraphics[width=0.7\linewidth]{02-Generacion_numeros_aleatorios_files/figure-latex/randu-1} 

}

\caption{Grafico de dispersión de tripletas del generador RANDU de IBM (contenidas en 15 planos).}\label{fig:randu}
\end{figure}

En general todos los generadores de este tipo van a presentar estructuras reticulares.
Marsaglia (1968) demostró que las \(k\)-uplas de un generadores multiplicativo están contenidas en a lo sumo \(\left(k!m\right)^{1/k}\) hiperplanos paralelos (para más detalles sobre la estructura reticular, ver por ejemplo Ripley, 1987, sección 2.7).
Por tanto habría que seleccionar adecuadamente \(m\) y \(c\) (\(a\) solo influiría en la pendiente) de forma que la estructura reticular sea imperceptible teniendo en cuenta el número de datos que se pretende generar (por ejemplo de forma que la distancia mínima entre los puntos sea próxima a la esperada en teoría).

Se han propuesto diversas pruebas (ver Sección \ref{calgen}) para
determinar si un generador tiene problemas de este tipo y se han
realizado numerosos estudios para determinadas familias (e.g.~Park y
Miller, 1988, estudiaron que parámetros son adecuados para \(m=2^{31}-1\)).

\begin{itemize}
\item
  En ciertos contextos muy exigentes (por ejemplo en criptografía), se recomienda
  considerar un ``periodo de seguridad'' \(\approx \sqrt{p}\) para evitar este tipo
  de problemas.
\item
  Aunque estos generadores tienen limitaciones en su capacidad para
  producir secuencias muy largas de números i.i.d. \(\mathcal{U}(0,1)\),
  son un elemento básico en generadores más avanzados (siguiente sección).
\end{itemize}

\begin{example}
\protect\hypertarget{exm:congru512}{}{\label{exm:congru512} }
\end{example}

Consideramos el generador congruencial, de ciclo máximo, definido por:
\[\begin{aligned}
x_{n+1}  & =(5x_{n}+1)\ \bmod\ 512,\nonumber\\
u_{n+1}  & =\frac{x_{n+1}}{512},\ n=0,1,\dots\nonumber
\end{aligned}\]

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\item
  Generar 500 valores de este generador, obtener el tiempo de CPU,
  representar su distribución mediante un histograma (en escala
  de densidades) y compararla con la densidad teórica.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.rng}\NormalTok{(}\DecValTok{321}\NormalTok{, }\StringTok{"lcg"}\NormalTok{, }\AttributeTok{a =} \DecValTok{5}\NormalTok{, }\AttributeTok{c =} \DecValTok{1}\NormalTok{, }\AttributeTok{m =} \DecValTok{512}\NormalTok{)  }\CommentTok{\# Establecer semilla y parámetros}
\NormalTok{nsim }\OtherTok{\textless{}{-}} \DecValTok{500}
\FunctionTok{system.time}\NormalTok{(u }\OtherTok{\textless{}{-}} \FunctionTok{rng}\NormalTok{(nsim)) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    user  system elapsed 
##       0       0       0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{hist}\NormalTok{(u, }\AttributeTok{freq =} \ConstantTok{FALSE}\NormalTok{)}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{h =} \DecValTok{1}\NormalTok{)                   }\CommentTok{\# Densidad uniforme}
\end{Highlighting}
\end{Shaded}

  \begin{figure}[!htb]

  {\centering \includegraphics[width=0.7\linewidth]{02-Generacion_numeros_aleatorios_files/figure-latex/ejcona-1} 

  }

  \caption{Histograma de los valores generados.}\label{fig:ejcona}
  \end{figure}

  En este caso concreto la distribución de los valores generados es aparentemente más uniforme de lo que cabría esperar, lo que induciría a sospechar de la calidad de este generador (ver Ejemplo \ref{exm:congru512b} en Sección \ref{calgen}).
\item
  Calcular la media de las simulaciones (\texttt{mean}) y compararla con
  la teórica.

  La aproximación por simulación de la media teórica es:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(u)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.4999609
\end{verbatim}

  La media teórica es 0.5.
  Error absoluto \(\ensuremath{3.90625\times 10^{-5}}\).
\item
  Aproximar (mediante simulación) la probabilidad del intervalo
  \((0.4;0.8)\) y compararla con la teórica.

  La probabilidad teórica es 0.8 - 0.4 = 0.4

  La aproximación mediante simulación:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{((}\FloatTok{0.4} \SpecialCharTok{\textless{}}\NormalTok{ u) }\SpecialCharTok{\&}\NormalTok{ (u }\SpecialCharTok{\textless{}} \FloatTok{0.8}\NormalTok{))}\SpecialCharTok{/}\NormalTok{nsim}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.402
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{((}\FloatTok{0.4} \SpecialCharTok{\textless{}}\NormalTok{ u) }\SpecialCharTok{\&}\NormalTok{ (u }\SpecialCharTok{\textless{}} \FloatTok{0.8}\NormalTok{))     }\CommentTok{\# Alternativa}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.402
\end{verbatim}
\end{enumerate}

\hypertarget{extensiones}{%
\section{Extensiones}\label{extensiones}}

Se han considerado diversas extensiones del generador congruencial lineal simple:

\begin{itemize}
\item
  Lineal múltiple:
  \(x_{i}= a_0 + a_1 x_{i-1} + a_2 x_{i-2} + \cdots + a_{k} x_{i-k} \bmod m\),
  con periodo \(p\leq m^{k}-1\).
\item
  No lineal:
  \(x_{i} = f\left( x_{i-1}, x_{i-2}, \cdots, x_{i-k} \right) \bmod m\).
  Por ejemplo \(x_{i} = a_0 + a_1 x_{i-1} + a_2 x_{i-1}^2 \bmod m\).
\item
  Matricial:
  \(\boldsymbol{x}_{i} = A_0 + A_1\boldsymbol{x}_{i-1} + A_2\boldsymbol{x}_{i-2} + \cdots + A_{k}\boldsymbol{x}_{i-k} \bmod m\).
\end{itemize}

Un ejemplo de generador congruencia lineal múltiple es el denominado \emph{generador de Fibonacci retardado} (Fibonacci-lagged generator; Knuth, 1969):
\[x_n = (x_{n-37} + x_{n-100}) \bmod 2^{30},\]
con un período aproximado de \(2^{129}\) y que puede ser empleado en R (lo cual no sería en principio recomendable; ver \href{https://www-cs-faculty.stanford.edu/~knuth/news02.html\#rng}{Knuth Recent News 2002}) estableciendo \texttt{kind} a \texttt{"Knuth-TAOCP-2002"} o \texttt{"Knuth-TAOCP"} en la llamada a \texttt{set.seed()} o \texttt{RNGkind()}.

El generador \emph{Mersenne-Twister} (Matsumoto y Nishimura, 1998), empleado por defecto en R, de periodo \(2^{19937}-1\) y equidistribution en 623 dimensiones, se puede expresar como un generador congruencial matricial lineal.
En cada iteración (\emph{twist}) genera 624 valores (los últimos componentes de la semilla son los 624 enteros de 32 bits correspondientes, el segundo componente es el índice/posición correspondiente al último valor devuelto; el conjunto de enteros solo cambia cada 624 generaciones).

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{u }\OtherTok{\textless{}{-}} \FunctionTok{runif}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{seed }\OtherTok{\textless{}{-}}\NormalTok{ .Random.seed}
\NormalTok{u }\OtherTok{\textless{}{-}} \FunctionTok{runif}\NormalTok{(}\DecValTok{623}\NormalTok{)}
\FunctionTok{sum}\NormalTok{(seed }\SpecialCharTok{!=}\NormalTok{ .Random.seed) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Solo cambia el índice: }
\NormalTok{seed[}\DecValTok{2}\NormalTok{]; .Random.seed[}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

\begin{verbatim}
## [1] 624
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{u }\OtherTok{\textless{}{-}} \FunctionTok{runif}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\CommentTok{\# Cada 624 generaciones cambia el conjunto de enteros y el índice se inicializa}
\FunctionTok{sum}\NormalTok{(seed }\SpecialCharTok{!=}\NormalTok{ .Random.seed)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 624
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{seed[}\DecValTok{2}\NormalTok{]; .Random.seed[}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

\begin{verbatim}
## [1] 1
\end{verbatim}

Un caso particular del generador lineal múltiple son los denominados \emph{generadores de registros desfasados} (más relacionados con la criptografía).
Se generan bits de forma secuencial considerando \(m=2\) y \(a_{i} \in \left \{ 0,1\right \}\) y se van combinando \(l\) bits para obtener valores en el intervalo \((0, 1)\), por ejemplo \(u_i = 0 . x_{it+1} x_{it+2} \ldots x_{it+l}\), siendo \(t\) un parámetro denominado \emph{aniquilación} (Tausworthe, 1965).
Los cálculos se pueden realizar rápidamente mediante operaciones lógicas (los sumandos de la combinación lineal se traducen en un ``o'' exclusivo XOR), empleando directamente los registros del procesador (ver por ejemplo, Ripley, 1987, Algoritmo 2.1).

Otras alternativas consisten en la combinanción de varios generadores, las más empleadas son:

\begin{itemize}
\item
  Combinar las salidas: por ejemplo \(u_{i}=\sum_{l=1}^L u_{i}^{(l)} \bmod 1\), donde \(u_{i}^{(l)}\) es el \(i\)-ésimo valor obtenido con el generador \(l\).
\item
  Barajar las salidas: por ejemplo se crea una tabla empleando un generador y se utiliza otro para seleccionar el índice del valor que se va a devolver y posteriormente actualizar.
\end{itemize}

El generador \emph{L'Ecuyer-CMRG} (L'Ecuyer, 1999), empleado como base para la generación de múltiples secuencias en el paquete \texttt{parallel}, combina dos generadores concruenciales lineales múltiples de orden \(k=3\) (el periodo aproximado es \(2^{191}\)).

\hypertarget{calgen}{%
\section{Análisis de la calidad de un generador}\label{calgen}}

Para verificar si un generador tiene las propiedades estadísticas deseadas hay disponibles una gran cantidad de test de hipótesis y métodos gráficos,
incluyendo métodos genéricos (de bondad de ajuste y aleatoriedad) y contrastes específicos para generadores aleatorios.
Se trata principalmente de contrastar si las muestras generadas son i.i.d. \(\mathcal{U}\left(0,1\right)\) (análisis univariante).
Aunque los métodos más avanzados tratan de contrastar si las \(d\)-uplas:

\[(U_{t+1},U_{t+2},\ldots,U_{t+d}); \ t=(i-1)d, \ i=1,\ldots,m\]

son i.i.d. \(\mathcal{U}\left(0,1\right)^{d}\) (uniformes independientes en el hipercubo; análisis multivariante).
En el Apéndice \ref{gof-aleat} se describen algunos de estos métodos.

En esta sección emplearemos únicamente métodos genéricos, ya que también pueden ser de utilidad para evaluar generadores de variables no uniformes y para la construcción de modelos del sistema real (e.g.~para modelar variables que se tratarán como entradas del modelo general).
Sin embargo, los métodos clásicos pueden no ser muy adecuados para evaluar generadores de números pseudoaleatorios (ver L'Ecuyer y Simard, 2007).
La recomendación sería emplear baterías de contrastes recientes, como las descritas en la Subsección \ref{baterias}.

Hay que destacar algunas diferencias entre el uso de este tipo de métodos en inferencia y en simulación.
Por ejemplo, si empleamos un constrate de hipótesis del modo habitual, desconfiamos del generador si la muestra (secuencia) no se ajusta a la distribución teórica (\(p\)-valor \(\leq \alpha\)).
En simulación, además, también se sospecha si se ajusta demasiado bien a la distribución teórica (\(p\)-valor \(\geq1-\alpha\)), lo que indicaría que no reproduce adecuadamente la variabilidad.

Uno de los contrastes más conocidos es el test chi-cuadrado de bondad de ajuste (\texttt{chisq.test} para el caso discreto).
Aunque si la variable de interés es continua, habría que discretizarla (con la correspondiente perdida de información).
Por ejemplo, se podría emplear la función \texttt{simres::chisq.cont.test()} (fichero \href{R/test.R}{\emph{test.R}}), que imita a las incluidas en R:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{simres}\SpecialCharTok{::}\NormalTok{chisq.cont.test}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## function(x, distribution = "norm", nclass = floor(length(x)/5),
##                             output = TRUE, nestpar = 0, ...) {
##   # Función distribución
##   q.distrib <- eval(parse(text = paste("q", distribution, sep = "")))
##   # Puntos de corte
##   q <- q.distrib((1:(nclass - 1))/nclass, ...)
##   tol <- sqrt(.Machine$double.eps)
##   xbreaks <- c(min(x) - tol, q, max(x) + tol)
##   # Gráficos y frecuencias
##   if (output) {
##     xhist <- hist(x, breaks = xbreaks, freq = FALSE,
##                   lty = 2, border = "grey50")
##     # Función densidad
##     d.distrib <- eval(parse(text = paste("d", distribution, sep = "")))
##     curve(d.distrib(x, ...), add = TRUE)
##   } else {
##     xhist <- hist(x, breaks = xbreaks, plot = FALSE)
##   }
##   # Cálculo estadístico y p-valor
##   O <- xhist$counts  # Equivalente a table(cut(x, xbreaks)) pero más eficiente
##   E <- length(x)/nclass
##   DNAME <- deparse(substitute(x))
##   METHOD <- "Pearson's Chi-squared test"
##   STATISTIC <- sum((O - E)^2/E)
##   names(STATISTIC) <- "X-squared"
##   PARAMETER <- nclass - nestpar - 1
##   names(PARAMETER) <- "df"
##   PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)
##   # Preparar resultados
##   classes <- format(xbreaks)
##   classes <- paste("(", classes[-(nclass + 1)], ",", classes[-1], "]",
##                    sep = "")
##   RESULTS <- list(classes = classes, observed = O, expected = E,
##                   residuals = (O - E)/sqrt(E))
##   if (output) {
##     cat("\nPearson's Chi-squared test table\n")
##     print(as.data.frame(RESULTS))
##   }
##   if (any(E < 5))
##     warning("Chi-squared approximation may be incorrect")
##   structure(c(list(statistic = STATISTIC, parameter = PARAMETER, p.value = PVAL,
##                    method = METHOD, data.name = DNAME), RESULTS), class = "htest")
## }
## <bytecode: 0x00000000353baee8>
## <environment: namespace:simres>
\end{verbatim}

\begin{example}[análisis de un generador congruencial, continuación]
\protect\hypertarget{exm:congru512b}{}{\label{exm:congru512b} \iffalse (análisis de un generador congruencial, continuación) \fi{} }
\end{example}

Continuando con el generador congruencial del Ejemplo \ref{exm:congru512}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.rng}\NormalTok{(}\DecValTok{321}\NormalTok{, }\StringTok{"lcg"}\NormalTok{, }\AttributeTok{a =} \DecValTok{5}\NormalTok{, }\AttributeTok{c =} \DecValTok{1}\NormalTok{, }\AttributeTok{m =} \DecValTok{512}\NormalTok{)  }\CommentTok{\# Establecer semilla y parámetros}
\NormalTok{nsim }\OtherTok{\textless{}{-}} \DecValTok{500}
\NormalTok{u }\OtherTok{\textless{}{-}} \FunctionTok{rng}\NormalTok{(nsim)}
\end{Highlighting}
\end{Shaded}

Al aplicar el test chi-cuadrado obtendríamos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{chisq.cont.test}\NormalTok{(u, }\AttributeTok{distribution =} \StringTok{"unif"}\NormalTok{, }
                \AttributeTok{nclass =} \DecValTok{10}\NormalTok{, }\AttributeTok{nestpar =} \DecValTok{0}\NormalTok{, }\AttributeTok{min =} \DecValTok{0}\NormalTok{, }\AttributeTok{max =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[!htb]

{\centering \includegraphics[width=0.7\linewidth]{02-Generacion_numeros_aleatorios_files/figure-latex/chisq-test-unif-1} 

}

\caption{Gráfico resultante de aplicar la función `chisq.cont.test()` comparando el histograma de los valores generados con la densidad uniforme.}\label{fig:chisq-test-unif}
\end{figure}

\begin{verbatim}
## 
## Pearson's Chi-squared test table
##                          classes observed expected  residuals
## 1  (-1.490116e-08, 1.000000e-01]       51       50  0.1414214
## 2  ( 1.000000e-01, 2.000000e-01]       49       50 -0.1414214
## 3  ( 2.000000e-01, 3.000000e-01]       49       50 -0.1414214
## 4  ( 3.000000e-01, 4.000000e-01]       50       50  0.0000000
## 5  ( 4.000000e-01, 5.000000e-01]       51       50  0.1414214
## 6  ( 5.000000e-01, 6.000000e-01]       51       50  0.1414214
## 7  ( 6.000000e-01, 7.000000e-01]       49       50 -0.1414214
## 8  ( 7.000000e-01, 8.000000e-01]       50       50  0.0000000
## 9  ( 8.000000e-01, 9.000000e-01]       50       50  0.0000000
## 10 ( 9.000000e-01, 9.980469e-01]       50       50  0.0000000
\end{verbatim}

\begin{verbatim}
## 
##  Pearson's Chi-squared test
## 
## data:  u
## X-squared = 0.12, df = 9, p-value = 1
\end{verbatim}

Alternativamente, por ejemplo si solo se pretende aplicar el contraste, se podría emplear la función \texttt{simres::freq.test()} (fichero \href{R/test.R}{\emph{test.R}}) para este caso particular (ver Sección \ref{freq-test}).

Como se muestra en la Figura \ref{fig:chisq-test-unif} el histograma de la secuencia generada es muy plano (comparado con lo que cabría esperar de una muestra de tamaño 500 de una uniforme), y consecuentemente el \(p\)-valor del contraste chi-cuadrado es prácticamente 1, lo que indicaría que este generador no reproduce adecuadamente la variabilidad de una distribución uniforme.

Otro contraste de bondad de ajuste muy conocido es el test de Kolmogorov-Smirnov, implementado en \texttt{ks.test} (ver Sección \ref{ks-test}).
Este contraste de hipótesis compara la función de distribución bajo la hipótesis nula con la función de distribución empírica (ver Sección \ref{empdistr}), representadas en la Figura \ref{fig:empdistrunif}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Distribución empírica}
\FunctionTok{curve}\NormalTok{(}\FunctionTok{ecdf}\NormalTok{(u)(x), }\AttributeTok{type =} \StringTok{"s"}\NormalTok{, }\AttributeTok{lwd =} \DecValTok{2}\NormalTok{)}
\FunctionTok{curve}\NormalTok{(}\FunctionTok{punif}\NormalTok{(x, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{), }\AttributeTok{add =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[!htb]

{\centering \includegraphics[width=0.7\linewidth]{02-Generacion_numeros_aleatorios_files/figure-latex/empdistrunif-1} 

}

\caption{Comparación de la distribución empírica de la secuencia generada con la función de distribución uniforme.}\label{fig:empdistrunif}
\end{figure}

Podemos realizar el contraste con el siguiente código:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Test de Kolmogorov{-}Smirnov}
\FunctionTok{ks.test}\NormalTok{(u, }\StringTok{"punif"}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##  One-sample Kolmogorov-Smirnov test
## 
## data:  u
## D = 0.0033281, p-value = 1
## alternative hypothesis: two-sided
\end{verbatim}

En la Sección \ref{gof} se describen con más detalle estos contrastes de bondad de ajuste.

Adicionalmente podríamos estudiar la aleatoriedad de los valores generados (ver Sección \ref{diag-aleat}), por ejemplo mediante un gráfico secuencial y el de dispersión retardado.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{plot}\NormalTok{(}\FunctionTok{as.ts}\NormalTok{(u))}
\end{Highlighting}
\end{Shaded}

\begin{figure}[!htb]

{\centering \includegraphics[width=0.7\linewidth]{02-Generacion_numeros_aleatorios_files/figure-latex/plot-sec-1} 

}

\caption{Gráfico secuencial de los valores generados.}\label{fig:plot-sec}
\end{figure}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{plot}\NormalTok{(u[}\SpecialCharTok{{-}}\NormalTok{nsim],u[}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{figure}[!htb]

{\centering \includegraphics[width=0.7\linewidth]{02-Generacion_numeros_aleatorios_files/figure-latex/plot-ret-1} 

}

\caption{Gráfico de dispersión retardado de los valores generados.}\label{fig:plot-ret}
\end{figure}

También podemos analizar las autocorrelaciones (las correlaciones de \((u_{i},u_{i+k})\), con \(k=1,\ldots,K\)):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{acf}\NormalTok{(u)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[!htb]

{\centering \includegraphics[width=0.7\linewidth]{02-Generacion_numeros_aleatorios_files/figure-latex/plot-acf-1} 

}

\caption{Autocorrelaciones de los valores generados.}\label{fig:plot-acf}
\end{figure}

Por ejemplo, para contrastar si las diez primeras autocorrelaciones son nulas podríamos emplear el test de Ljung-Box:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Box.test}\NormalTok{(u, }\AttributeTok{lag =} \DecValTok{10}\NormalTok{, }\AttributeTok{type =} \StringTok{"Ljung"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##  Box-Ljung test
## 
## data:  u
## X-squared = 22.533, df = 10, p-value = 0.01261
\end{verbatim}

\hypertarget{repeticiuxf3n-de-contrastes}{%
\subsection{Repetición de contrastes}\label{repeticiuxf3n-de-contrastes}}

Los contrastes se plantean habitualmente desde el punto de vista de la inferencia estadística: se realiza una prueba sobre la única muestra disponible.
Si se realiza una única prueba, en las condiciones de \(H_0\) hay una probabilidad \(\alpha\) de rechazarla.
En simulación tiene mucho más sentido realizar un gran número de pruebas:

\begin{itemize}
\item
  La proporción de rechazos debería aproximarse al valor de
  \(\alpha\) (se puede comprobar para distintos valores de \(\alpha\)).
\item
  La distribución del estadístico debería ajustarse a la teórica
  bajo \(H_0\) (se podría realizar un nuevo contraste de bondad
  de ajuste).
\item
  Los \(p\)-valores obtenidos deberían ajustarse a una
  \(\mathcal{U}\left(0,1\right)\) (se podría realizar también un
  contraste de bondad de ajuste).
\end{itemize}

Este procedimiento es también el habitual para validar un método de
contraste de hipótesis por simulación (ver Sección \ref{contrastes}).

\begin{example}
\protect\hypertarget{exm:rep-test-randu}{}{\label{exm:rep-test-randu} }
\end{example}

Continuando con el generador congruencial RANDU, podemos pensar en estudiar la uniformidad de los valores generados empleando repetidamente el test chi-cuadrado:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Valores iniciales}
\FunctionTok{set.rng}\NormalTok{(}\DecValTok{543210}\NormalTok{, }\StringTok{"lcg"}\NormalTok{, }\AttributeTok{a =} \DecValTok{2}\SpecialCharTok{\^{}}\DecValTok{16} \SpecialCharTok{+} \DecValTok{3}\NormalTok{, }\AttributeTok{c =} \DecValTok{0}\NormalTok{, }\AttributeTok{m =} \DecValTok{2}\SpecialCharTok{\^{}}\DecValTok{31}\NormalTok{)  }\CommentTok{\# Establecer semilla y parámetros}
\CommentTok{\# set.seed(543210)}
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{500}
\NormalTok{nsim }\OtherTok{\textless{}{-}} \DecValTok{1000}
\NormalTok{estadistico }\OtherTok{\textless{}{-}} \FunctionTok{numeric}\NormalTok{(nsim)}
\NormalTok{pvalor }\OtherTok{\textless{}{-}} \FunctionTok{numeric}\NormalTok{(nsim)}

\CommentTok{\# Realizar contrastes}
\ControlFlowTok{for}\NormalTok{(isim }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\NormalTok{nsim) \{}
\NormalTok{  u }\OtherTok{\textless{}{-}} \FunctionTok{rng}\NormalTok{(n)    }\CommentTok{\# Generar}
  \CommentTok{\# u \textless{}{-} runif(n)}
\NormalTok{  tmp }\OtherTok{\textless{}{-}} \FunctionTok{freq.test}\NormalTok{(u, }\AttributeTok{nclass =} \DecValTok{100}\NormalTok{)}
  \CommentTok{\# tmp \textless{}{-} chisq.cont.test(u, distribution = "unif", nclass = 100, }
  \CommentTok{\#     output = FALSE, nestpar = 0, min = 0, max = 1)}
\NormalTok{  estadistico[isim] }\OtherTok{\textless{}{-}}\NormalTok{ tmp}\SpecialCharTok{$}\NormalTok{statistic}
\NormalTok{  pvalor[isim] }\OtherTok{\textless{}{-}}\NormalTok{ tmp}\SpecialCharTok{$}\NormalTok{p.value}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Por ejemplo, podemos comparar la proporción de rechazos observados con los que cabría esperar con los niveles de significación habituales:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\{}
\FunctionTok{cat}\NormalTok{(}\StringTok{"Proporción de rechazos al 1\% ="}\NormalTok{, }\FunctionTok{mean}\NormalTok{(pvalor }\SpecialCharTok{\textless{}} \FloatTok{0.01}\NormalTok{), }\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{) }\CommentTok{\# sum(pvalor \textless{} 0.01)/nsim}
\FunctionTok{cat}\NormalTok{(}\StringTok{"Proporción de rechazos al 5\% ="}\NormalTok{, }\FunctionTok{mean}\NormalTok{(pvalor }\SpecialCharTok{\textless{}} \FloatTok{0.05}\NormalTok{), }\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)   }\CommentTok{\# sum(pvalor \textless{} 0.05)/nsim}
\FunctionTok{cat}\NormalTok{(}\StringTok{"Proporción de rechazos al 10\% ="}\NormalTok{, }\FunctionTok{mean}\NormalTok{(pvalor }\SpecialCharTok{\textless{}} \FloatTok{0.1}\NormalTok{), }\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)   }\CommentTok{\# sum(pvalor \textless{} 0.1)/nsim}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Proporción de rechazos al 1% = 0.014 
## Proporción de rechazos al 5% = 0.051 
## Proporción de rechazos al 10% = 0.112
\end{verbatim}

Las proporciones de rechazo obtenidas deberían comportarse como una aproximación por simulación de los niveles teóricos.
En este caso no se observa nada extraño, por lo que no habría motivos para sospechar de la uniformidad de los valores generados (aparentemente no hay problemas con la uniformidad de este generador).

Adicionalmente, si queremos estudiar la proporción de rechazos (el \emph{tamaño del contraste}) para los posibles valores de \(\alpha\), podemos emplear la distribución empírica del \(p\)-valor (proporción de veces que resultó menor que un determinado valor):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Distribución empírica}
\FunctionTok{plot}\NormalTok{(}\FunctionTok{ecdf}\NormalTok{(pvalor), }\AttributeTok{do.points =} \ConstantTok{FALSE}\NormalTok{, }\AttributeTok{lwd =} \DecValTok{2}\NormalTok{, }
     \AttributeTok{xlab =} \StringTok{\textquotesingle{}Nivel de significación\textquotesingle{}}\NormalTok{, }\AttributeTok{ylab =} \StringTok{\textquotesingle{}Proporción de rechazos\textquotesingle{}}\NormalTok{)}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{a =} \DecValTok{0}\NormalTok{, }\AttributeTok{b =} \DecValTok{1}\NormalTok{, }\AttributeTok{lty =} \DecValTok{2}\NormalTok{)   }\CommentTok{\# curve(punif(x, 0, 1), add = TRUE)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[!htb]

{\centering \includegraphics[width=0.7\linewidth]{02-Generacion_numeros_aleatorios_files/figure-latex/rep-test-ecdf-1} 

}

\caption{Proporción de rechazos con los distintos niveles de significación.}\label{fig:rep-test-ecdf}
\end{figure}

También podemos estudiar la distribución del estadístico del contraste.
En este caso, como la distribución bajo la hipótesis nula está implementada en R, podemos compararla fácilmente con la de los valores generados (debería ser una aproximación por simulación de la distribución teórica):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Histograma}
\FunctionTok{hist}\NormalTok{(estadistico, }\AttributeTok{breaks =} \StringTok{"FD"}\NormalTok{, }\AttributeTok{freq =} \ConstantTok{FALSE}\NormalTok{, }\AttributeTok{main =} \StringTok{""}\NormalTok{)}
\FunctionTok{curve}\NormalTok{(}\FunctionTok{dchisq}\NormalTok{(x, }\DecValTok{99}\NormalTok{), }\AttributeTok{add =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[!htb]

{\centering \includegraphics[width=0.7\linewidth]{02-Generacion_numeros_aleatorios_files/figure-latex/rep-test-est-1} 

}

\caption{Distribución del estadístico del constraste.}\label{fig:rep-test-est}
\end{figure}

Además de la comparación gráfica, podríamos emplear un test de bondad de ajuste para contrastar si la distribución del estadístico es la teórica bajo la hipótesis nula:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Test chi{-}cuadrado (chi{-}cuadrado sobre chi{-}cuadrado)}
\CommentTok{\# chisq.cont.test(estadistico, distribution="chisq", nclass=20, nestpar=0, df=99)}
\CommentTok{\# Test de Kolmogorov{-}Smirnov}
\FunctionTok{ks.test}\NormalTok{(estadistico, }\StringTok{"pchisq"}\NormalTok{, }\AttributeTok{df =} \DecValTok{99}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##  One-sample Kolmogorov-Smirnov test
## 
## data:  estadistico
## D = 0.023499, p-value = 0.6388
## alternative hypothesis: two-sided
\end{verbatim}

En este caso la distribución observada del estadístico es la que cabría esperar de una muestra de este tamaño de la distribución teórica, por tanto, según este criterio, aparentemente no habría problemas con la uniformidad de este generador (hay que recordar que estamos utilizando contrastes de hipótesis como herramienta para ver si hay algún problema con el generador, no tiene mucho sentido hablar de aceptar o rechazar una hipótesis).

En lugar de estudiar la distribución del estadístico de contraste siempre podemos analizar la distribución del \(p\)-valor.
Mientras que la distribución teórica del estadístico depende del contraste y puede ser complicada, la del \(p\)-valor es siempre una uniforme.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Histograma}
\FunctionTok{hist}\NormalTok{(pvalor, }\AttributeTok{freq =} \ConstantTok{FALSE}\NormalTok{, }\AttributeTok{main =} \StringTok{""}\NormalTok{)}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{h=}\DecValTok{1}\NormalTok{) }\CommentTok{\# curve(dunif(x,0,1), add=TRUE)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[!htb]

{\centering \includegraphics[width=0.7\linewidth]{02-Generacion_numeros_aleatorios_files/figure-latex/rep-test-pval-1} 

}

\caption{Distribución del $p$-valor del constraste.}\label{fig:rep-test-pval}
\end{figure}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Test chi{-}cuadrado}
\CommentTok{\# chisq.cont.test(pvalor, distribution="unif", nclass=20, nestpar=0, min=0, max=1)}
\CommentTok{\# Test de Kolmogorov{-}Smirnov}
\FunctionTok{ks.test}\NormalTok{(pvalor, }\StringTok{"punif"}\NormalTok{,  }\AttributeTok{min =} \DecValTok{0}\NormalTok{, }\AttributeTok{max =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##  One-sample Kolmogorov-Smirnov test
## 
## data:  pvalor
## D = 0.023499, p-value = 0.6388
## alternative hypothesis: two-sided
\end{verbatim}

Como podemos observar, obtendríamos los mismos resultados que al analizar la distribución del estadístico.

\hypertarget{baterias}{%
\subsection{Baterías de contrastes}\label{baterias}}

Hay numerosos ejemplos de generadores que pasaron diferentes test de uniformidad y aleatoriedad pero que fallaron estrepitosamente al considerar nuevos contrastes diseñados específicamente para generadores aleatorios (ver Marsaglia \emph{et al.}, 1990).
Por este motivo, el procedimiento habitual en la práctica es aplicar un número más o menos elevado de contrastes (de distinto tipo y difíciles de pasar, e.g.~Marsaglia y Tsang, 2002), de forma que si el generador los pasa tendremos mayor confianza en que sus propiedades son las adecuadas.
Este conjunto de pruebas es lo que se denomina batería de contrastes. Una de las primeras se introdujo en Knuth (1969) y de las más recientes podríamos destacar:

\begin{itemize}
\item
  Diehard tests (The Marsaglia Random Number CDROM, 1995):
  \href{https://web.archive.org/web/20160125103112/http://stat.fsu.edu/pub/diehard}{http://www.stat.fsu.edu/pub/diehard (versión archivada el 2016-01-25)}.
\item
  Dieharder (Brown y Bauer, 2003):
  \href{https://webhome.phy.duke.edu/~rgb/General/dieharder.php}{Dieharder Page},
  paquete \href{https://github.com/eddelbuettel/rdieharder}{\texttt{RDieHarder}}.
\item
  TestU01 (L'Ecuyer y Simard, 2007):
  \url{http://simul.iro.umontreal.ca/testu01/tu01.html}.
\item
  NIST test suite (National Institute of Standards and Technology, USA, 2010):
  \url{http://csrc.nist.gov/groups/ST/toolkit/rng}.
\end{itemize}

Para más detalles, ver por ejemplo\footnote{También puede ser de interés el enlace \href{http://www.ciphersbyritter.com/RES/RANDTEST.HTM}{Randomness Tests: A Literature Survey} y la entidad certificadora (gratuita) en línea \href{http://www.cacert.at/random}{CAcert}.}:

\begin{itemize}
\item
  Marsaglia, G. y Tsang, W.W. (2002). \href{http://www.jstatsoft.org/v07/i03}{Some difficult-to-pass tests of randomness}. Journal of Statistical Software, 7(3), 1-9.
\item
  Demirhan, H. y Bitirim, N. (2016). \href{https://journal.r-project.org/archive/2016/RJ-2016-016/index.html}{CryptRndTest: an R package for testing the cryptographic randomness}. The R Journal, 8(1), 233-247.
\end{itemize}

Estas baterías de contrastes se suelen emplear si el generador va a ser utilizado en criptografía o si es muy importante la impredecibilidad (normalmente con generadores de números ``verdaderamente aleatorios'' por hardware).
Si el objetivo es únicamente obtener resultados estadísticos (como en nuestro caso) no sería tan importante que el generador no superase alguno de estos test.

\hypertarget{ejercicios-1}{%
\section{Ejercicios}\label{ejercicios-1}}

\begin{exercise}[Método de los cuadrados medios]
\protect\hypertarget{exr:RANDVN}{}{\label{exr:RANDVN} \iffalse (Método de los cuadrados medios) \fi{} }
\end{exercise}
Uno de los primeros generadores utilizados fue el denominado método de los
cuadrados medios propuesto por Von Neumann (1946). Con este
procedimiento se generan números pseudoaleatorios de 4 dígitos de la
siguiente forma:

\begin{enumerate}
\def\labelenumi{\roman{enumi}.}
\item
  Se escoge un número de cuatro dígitos \(x_0\) (semilla).
\item
  Se eleva al cuadrado (\(x_0^2\)) y se toman los cuatro dígitos centrales (\(x_1\)).
\item
  Se genera el número pseudo-aleatorio como \[u_1=\frac{x_1}{10^{4}}.\]
\item
  Volver al paso ii y repetir el proceso.
\end{enumerate}

Para obtener los \(k\) (número par) dígitos centrales de \(x_{i}^2\)
se puede utilizar que:
\[x_{i+1}=\left\lfloor \left(  x_{i}^2-\left\lfloor \dfrac{x_{i}^2}{10^{(2k-\frac{k}2)}}\right\rfloor 10^{(2k-\frac{k}2)}\right)
/10^{\frac{k}2}\right\rfloor\]

Este algoritmo está implementado en la función \texttt{simres::rvng()} (ver también \texttt{simres::rng()}; fichero \href{R/rng.R}{\emph{rng.R}}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{simres}\SpecialCharTok{::}\NormalTok{rvng}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## function(n, seed = as.numeric(Sys.time()), k = 4) {
##   seed <- seed %% 10^k
##   aux <- 10^(2*k-k/2)
##   aux2 <- 10^(k/2)
##   u <- numeric(n)
##   for(i in 1:n) {
##     z <- seed^2
##     seed <- trunc((z - trunc(z/aux)*aux)/aux2)
##     u[i] <- seed/10^k
##   }
##   # Almacenar semilla y parámetros
##   assign(".rng", list(seed = seed, type = "vm", parameters = list(k = k)),
##       envir = globalenv())
##   # .rng <<- list(seed = seed, type = "vm", parameters = list(k = k))
##   # Para continuar con semilla y parámetros:
##   #   with(.rng, rvng(n, seed, parameters$k))
##   # Devolver valores
##   return(u)
## }
## <bytecode: 0x00000000380cd258>
## <environment: namespace:simres>
\end{verbatim}

Estudiar las características del generador de cuadrados medios a partir de una secuencia de 500 valores.
Emplear únicamente métodos gráficos.

\begin{exercise}
\protect\hypertarget{exr:parkmiller}{}{\label{exr:parkmiller} }
\end{exercise}
Considerando el generador congruencial multiplicativo de parámetros \(a=7^{5}=16807\), \(c=0\) y \(m=2^{31}-1\) (\emph{minimal standar} de Park y Miller, 1988).
¿Se observan los mismos problemas que con el algoritmo RANDU al considerar las tripletas \((x_{k},x_{k+1},x_{k+2})\)?

\hypertarget{resultados}{%
\chapter{Análisis de resultados de simulación}\label{resultados}}

En este capítulo nos centraremos en la aproximación mediante simulación de la media teórica de un estadístico a partir de la media muestral de una secuencia de simulaciones de dicho estadístico.
La aproximación de una probabilidad sería un caso particular considerando una variable de Bernoulli.

En primer lugar se tratará el análisis de la convergencia y la precisión de la aproximación por simulación.
Al final del capítulo se incluye una breve introducción a los problemas de estabilización y dependencia (con los que nos solemos encontrar en simulación dinámica y MCMC).

\hypertarget{convergencia}{%
\section{Convergencia}\label{convergencia}}

Supongamos que estamos interesados en aproximar la media teórica \(\mu = E\left( X\right)\) a partir de una secuencia i.i.d. \(X_{1}\), \(X_{2}\), \(\ldots\), \(X_{n}\) obtenida mediante simulación, utilizando para ello la media muestral \(\bar{X}_{n}\).
Una justificación teórica de la validez de esta aproximación es \emph{la ley (débil\footnote{\emph{La ley fuerte} establece la convergencia casi segura.}) de los grandes números}:

\begin{theorem}[Ley débil de los grandes números; Khintchine, 1928]
\protect\hypertarget{thm:khinchine}{}{\label{thm:khinchine} \iffalse (Ley débil de los grandes números; Khintchine, 1928) \fi{} }
Si \(X_{1}\), \(X_{2}\), \(\ldots\) es una secuencia de variables aleatorias independientes e idénticamente distribuidas con media finita \(E\left( X_{i}\right) =\mu\) (i.e.~\(E\left( \left\vert X_{i} \right\vert \right) < \infty\)) entonces \(\overline{X}_{n}=\left( X_{1}+\ldots +X_{n}\right) /n\)
converge en probabilidad a \(\mu\): \[\overline{X}_{n}\ \overset{p}{ \longrightarrow }\ \mu\]
Es decir, para cualquier \(\varepsilon >0\):
\[\lim\limits_{n\rightarrow \infty }P\left( \left\vert \overline{X}_{n}-\mu
\right\vert <\varepsilon \right) = 1.\]
\end{theorem}

\begin{example}[Aproximación de una probabilidad]
\protect\hypertarget{exm:unnamed-chunk-2}{}{\label{exm:unnamed-chunk-2} \iffalse (Aproximación de una probabilidad) \fi{} }
\end{example}
Simulamos una variable aleatoria \(X\) con distribución de Bernoulli de parámetro \(p=0.5\):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OtherTok{\textless{}{-}} \FloatTok{0.5}
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{nsim }\OtherTok{\textless{}{-}} \DecValTok{10000} \CommentTok{\# nsim \textless{}{-} 100}
\NormalTok{rx }\OtherTok{\textless{}{-}} \FunctionTok{runif}\NormalTok{(nsim) }\SpecialCharTok{\textless{}}\NormalTok{ p }\CommentTok{\# rbinom(nsim, size = 1, prob = p)}
\end{Highlighting}
\end{Shaded}

La aproximación por simulación de \(E(X) = p\) será:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(rx) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.5047
\end{verbatim}

Podemos generar un gráfico con la evolución de la aproximación:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{plot}\NormalTok{(}\FunctionTok{cumsum}\NormalTok{(rx)}\SpecialCharTok{/}\DecValTok{1}\SpecialCharTok{:}\NormalTok{nsim, }\AttributeTok{type =} \StringTok{"l"}\NormalTok{, }\AttributeTok{lwd =} \DecValTok{2}\NormalTok{, }\AttributeTok{xlab =} \StringTok{"Número de generaciones"}\NormalTok{, }
     \AttributeTok{ylab =} \StringTok{"Proporción muestral"}\NormalTok{, }\AttributeTok{ylim =} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{))}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{h =} \FunctionTok{mean}\NormalTok{(rx), }\AttributeTok{lty =} \DecValTok{2}\NormalTok{)}
\CommentTok{\# valor teórico}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{h =}\NormalTok{ p) }
\end{Highlighting}
\end{Shaded}

\begin{figure}[!htb]

{\centering \includegraphics[width=0.7\linewidth]{03-Analisis_resultados_files/figure-latex/proporcion-1} 

}

\caption{Aproximación de la proporción en función del número de generaciones.}\label{fig:proporcion}
\end{figure}

\hypertarget{detecciuxf3n-de-problemas-de-convergencia}{%
\subsection{Detección de problemas de convergencia}\label{detecciuxf3n-de-problemas-de-convergencia}}

En la ley débil se requiere como condición suficiente que \(E\left( \left\vert X_{i} \right\vert \right) < \infty\), en caso contrario la media muestral puede no converger a una constante.
Un ejemplo conocido es la distribución de Cauchy:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{nsim }\OtherTok{\textless{}{-}} \DecValTok{10000}
\NormalTok{rx }\OtherTok{\textless{}{-}} \FunctionTok{rcauchy}\NormalTok{(nsim) }\CommentTok{\# rx \textless{}{-} rt(nsim, df = 2)}
\FunctionTok{plot}\NormalTok{(}\FunctionTok{cumsum}\NormalTok{(rx)}\SpecialCharTok{/}\DecValTok{1}\SpecialCharTok{:}\NormalTok{nsim, }\AttributeTok{type =} \StringTok{"l"}\NormalTok{, }\AttributeTok{lwd =} \DecValTok{2}\NormalTok{, }
     \AttributeTok{xlab =} \StringTok{"Número de generaciones"}\NormalTok{, }\AttributeTok{ylab =} \StringTok{"Media muestral"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[!htb]

{\centering \includegraphics[width=0.7\linewidth]{03-Analisis_resultados_files/figure-latex/cauchy-1} 

}

\caption{Evolución de la media muestral de una distribución de Cauchy en función del número de generaciones.}\label{fig:cauchy}
\end{figure}

Como conclusión, para detectar problemas de convergencia es especialmente recomendable representar la evolución de la aproximación de la característica de interés (sobre el número de generaciones),
además de realizar otros análisis descriptivos de las simulaciones.
Por ejemplo, en este caso podemos observar los valores que producen estos saltos mediante un gráfico de cajas:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{boxplot}\NormalTok{(rx)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[!htb]

{\centering \includegraphics[width=0.7\linewidth]{03-Analisis_resultados_files/figure-latex/cauchy-box-1} 

}

\caption{Gráfico de cajas de 10000 generaciones de una distribución de Cauchy.}\label{fig:cauchy-box}
\end{figure}

\hypertarget{precisiuxf3n}{%
\subsection{Precisión}\label{precisiuxf3n}}

Una forma de medir la precisión de un estimador es utilizando su varianza, o también su desviación típica que recibe el nombre de error estándar.
En el caso de la media muestral \(\overline{X}_{n}\), suponiendo además que \(Var\left( X_{i}\right) = \sigma^{2}<\infty\), un estimador
insesgado de \(Var\left( \overline{X}_{n}\right) =\sigma ^{2}/n\) es:
\[\widehat{Var}\left( \overline{X}_{n}\right) = \frac{\widehat{S}_n^{2}}{n}\]
donde:
\[\widehat{S}_{n}^{2}=\dfrac{1}{n-1}\sum\limits_{i=1}^{n}\left( X_{i}-
\overline{X}\right) ^{2}\]
es la cuasi-varianza muestral\footnote{Esto sería también válido para el caso de una proporción, donde \(E(X) = p\), \(Var(X) = p(1-p)\) y \(\hat{p}_{n} = \overline{X}_{n}\), obteniéndose que: \[\widehat{Var}\left( \hat{p}_{n}\right) = \frac{\widehat{S}_n^{2}}{n} = \frac{\hat{p}_{n}(1-\hat{p}_{n})}{n-1},\] aunque lo más habitual es emplear: \[\frac{S_n^{2}}{n} = \frac{\hat{p}_{n}(1-\hat{p}_{n})}{n},\]
  donde \(S_n^{2}\) es la varianza muestral. Hay que tener en cuenta que en simulación el número de generaciones es normalmente grande y en la práctica no va haber diferencias apreciables.}.

Los valores obtenidos servirían como medidas básicas de la precisión de la aproximación, aunque su principal aplicación es la construcción de intervalos de confianza.
Si se endurecen las suposiciones de la ley débil de los grandes números (Teorema \ref{thm:khinchine}), exigiendo la existencia de varianza finita (\(E\left( X_{i}^2 \right) < \infty\)), se dispone de un resultado más preciso sobre las variaciones de la aproximación por simulación en torno al límite teórico.

\begin{theorem}[central del límite, CLT]
\protect\hypertarget{thm:tcl}{}{\label{thm:tcl} \iffalse (central del límite, CLT) \fi{} }
Si \(X_{1}\), \(X_{2}\), \(\ldots\) es una secuencia de variables aleatorias independientes e idénticamente distribuidas con \(E\left( X_{i}\right) =\mu\) y
\(Var\left( X_{i}\right) = \sigma ^{2}<\infty\), entonces la media muestral estandarizada converge en distribución a una normal estándar:
\[Z_{n}=\frac{\overline{X}_{n}-\mu }{\frac{\sigma }{\sqrt{n}}}
\overset{d}{ \longrightarrow } N(0,1).\]
Es decir, \(\lim\limits_{n\rightarrow \infty }F_{Z_{n}}(z)=\Phi (z)\).
\end{theorem}

Por tanto, un intervalo de confianza asintótico para \(\mu\) es:
\[IC_{1-\alpha }(\mu ) = \left( \overline{X}_{n}
- z_{1-\alpha /2}\dfrac{\widehat{S}_{n}}{\sqrt{n}},\ 
\overline{X}_n+z_{1-\alpha /2}\dfrac{\widehat{S}_{n}}{\sqrt{n}} \right).\]

También podemos utilizar el error máximo (con nivel de confianza \(1-\alpha\)) de la estimación \(z_{1-\alpha /2}\dfrac{\widehat{S}_{n}}{\sqrt{n}}\) como medida de su precisión.

El CLT es un resultado asintótico. En la práctica la convergencia es aleatoria, ya que depende de la muestra simulada (las generaciones pseudoaleatorias).
Además, la convergencia puede considerarse lenta, en el sentido de que, por ejemplo, para doblar la precisión (disminuir el error a la mitad), necesitaríamos un número de generaciones cuatro veces mayor (Ver Sección \ref{num-gen}).
Pero una ventaja es que este error no depende del número de dimensiones (en el caso multidimensional puede ser mucho más rápida que otras alternativas numéricas; ver Apéndice \ref{int-num}).

\begin{example}[Aproximación de la media de una distribución normal]
\protect\hypertarget{exm:unnamed-chunk-5}{}{\label{exm:unnamed-chunk-5} \iffalse (Aproximación de la media de una distribución normal) \fi{} }
\end{example}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{xsd }\OtherTok{\textless{}{-}} \DecValTok{1}
\NormalTok{xmed }\OtherTok{\textless{}{-}} \DecValTok{0}
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{nsim }\OtherTok{\textless{}{-}} \DecValTok{1000}
\NormalTok{rx }\OtherTok{\textless{}{-}} \FunctionTok{rnorm}\NormalTok{(nsim, xmed, xsd)}
\end{Highlighting}
\end{Shaded}

La aproximación por simulación de la media será:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(rx)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -0.01164814
\end{verbatim}

Como medida de la precisión de la aproximación podemos utilizar el error máximo:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2}\SpecialCharTok{*}\FunctionTok{sd}\NormalTok{(rx)}\SpecialCharTok{/}\FunctionTok{sqrt}\NormalTok{(nsim)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.06545382
\end{verbatim}

(es habitual emplear 2 en lugar de 1.96,
lo que se correspondería con \(1 - \alpha = 0.9545\) en el caso de normalidad).
Podemos añadir también los correspondientes intervalos de confianza al gráfico de convergencia:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\NormalTok{nsim}
\NormalTok{est }\OtherTok{\textless{}{-}} \FunctionTok{cumsum}\NormalTok{(rx)}\SpecialCharTok{/}\NormalTok{n}
\CommentTok{\# (cumsum(rx\^{}2) {-} n*est\^{}2)/(n{-}1) \# Varianzas muestrales}
\NormalTok{esterr }\OtherTok{\textless{}{-}} \FunctionTok{sqrt}\NormalTok{((}\FunctionTok{cumsum}\NormalTok{(rx}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{)}\SpecialCharTok{/}\NormalTok{n }\SpecialCharTok{{-}}\NormalTok{ est}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{)}\SpecialCharTok{/}\NormalTok{(n}\DecValTok{{-}1}\NormalTok{)) }\CommentTok{\# Errores estándar}
\FunctionTok{plot}\NormalTok{(est, }\AttributeTok{type =} \StringTok{"l"}\NormalTok{, }\AttributeTok{lwd =} \DecValTok{2}\NormalTok{, }\AttributeTok{xlab =} \StringTok{"Número de generaciones"}\NormalTok{, }
     \AttributeTok{ylab =} \StringTok{"Media y rango de error"}\NormalTok{, }\AttributeTok{ylim =} \FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{))}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{h =}\NormalTok{ est[nsim], }\AttributeTok{lty=}\DecValTok{2}\NormalTok{)}
\FunctionTok{lines}\NormalTok{(est }\SpecialCharTok{+} \DecValTok{2}\SpecialCharTok{*}\NormalTok{esterr, }\AttributeTok{lty=}\DecValTok{3}\NormalTok{)}
\FunctionTok{lines}\NormalTok{(est }\SpecialCharTok{{-}} \DecValTok{2}\SpecialCharTok{*}\NormalTok{esterr, }\AttributeTok{lty=}\DecValTok{3}\NormalTok{)}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{h =}\NormalTok{ xmed)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[!htb]

{\centering \includegraphics[width=0.7\linewidth]{03-Analisis_resultados_files/figure-latex/conv-esterr-1} 

}

\caption{Gráfico de convergencia incluyendo el error de la aproximación.}\label{fig:conv-esterr}
\end{figure}

\hypertarget{num-gen}{%
\section{Determinación del número de generaciones}\label{num-gen}}

Lo más habitual es seleccionar un valor de \(n\) del orden de varias centenas o millares.
En los casos en los que la simulación se utiliza para aproximar una característica central de la distribución (como una media) puede bastar un número de generaciones del orden de \(n = 100, 200, 500\).
Sin embargo, en otros casos, por ejemplo para aproximar el p-valor de un contraste de hipótesis o construir intervalos de confianza, pueden ser necesarios valores del tipo \(n = 1000, 2000, 5000, 10000\).

En muchas ocasiones puede interesar obtener una aproximación con un nivel de precisión fijado.
Para una precisión absoluta \(\varepsilon\), se trata de determinar
\(n\) de forma que:
\[z_{1-\alpha /2}\dfrac{\widehat{S}_{n}}{\sqrt{n}}<\varepsilon\]

Un algoritmo podría ser el siguiente:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Hacer \(j=0\)
  y fijar un tamaño inicial \(n_{0}\) (e.g.~30 ó 60).
\item
  Generar \(\left\{ X_{i}\right\} _{i=1}^{n_{0}}\)
  y calcular \(\overline{X}_{n_0}\) y \(\widehat{S}_{n_{0}}\).
\item
  Mientras \(\left. z_{1-\alpha /2}\widehat{S}_{n_j}\right/ \sqrt{n_{j}}>\varepsilon\) hacer:

  3.1. \(j=j+1\).

  3.2. \(n_{j}=\left\lceil \left( \left. z_{1-\alpha /2}\widehat{S}  _{n_{j-1}}\right/ \varepsilon \right)^{2}\right\rceil\).

  3.3. Generar \(\left\{ X_{i}\right\}_{i=n_{j-1}+1}^{n_j}\)
  y calcular \(\overline{X}_{n_j}\) y \(\widehat{S}_{n_j}\).
\item
  Devolver \(\overline{X}_{n_j}\) y \(\left. z_{1-\alpha /2}\widehat{S}_{n_j}\right/ \sqrt{n_{j}}\).
\end{enumerate}

Para una precisión relativa \(\varepsilon \left\vert \mu \right\vert\) se procede análogamente de forma que:
\[z_{1-\alpha /2}\dfrac{\widehat{S}_{n}}{\sqrt{n}}<\varepsilon \left\vert 
\overline{X}_{n}\right\vert .\]

\hypertarget{el-problema-de-la-dependencia}{%
\section{El problema de la dependencia}\label{el-problema-de-la-dependencia}}

En el caso de dependencia, bajo condiciones muy generales se verifica la ley débil de los grandes números.
Sin embargo, la estimación de la precisión se complica:
\[Var\left( \overline{X}\right) =\frac{1}{n^{2}}\left( 
\sum_{i=1}^{n}Var\left( X_{i} \right) + 2\sum_{i<j}Cov\left( X_{i},X_{j}\right) \right).\]

\begin{example}[aproximación de una proporción bajo dependencia, cadena de Markov]
\protect\hypertarget{exm:mmc}{}{\label{exm:mmc} \iffalse (aproximación de una proporción bajo dependencia, cadena de Markov) \fi{} }
\end{example}
Supongamos que en A Coruña llueve de media uno de cada tres días al año,
y que la probabilidad de que un día llueva solo depende de lo que ocurrió el día anterior,
siendo 0.94 si el día anterior llovió y 0.03 si no.
Podemos generar valores de la variable indicadora de día lluvioso con el siguiente código:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Variable dicotómica 0/1 (FALSE/TRUE)  }
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{nsim }\OtherTok{\textless{}{-}} \DecValTok{10000}
\NormalTok{alpha }\OtherTok{\textless{}{-}} \FloatTok{0.03} \CommentTok{\# prob de cambio si seco}
\NormalTok{beta }\OtherTok{\textless{}{-}} \FloatTok{0.06}  \CommentTok{\# prob de cambio si lluvia}
\NormalTok{rx }\OtherTok{\textless{}{-}} \FunctionTok{logical}\NormalTok{(nsim) }\CommentTok{\# x == "llueve"}
\NormalTok{rx[}\DecValTok{1}\NormalTok{] }\OtherTok{\textless{}{-}} \ConstantTok{FALSE} \CommentTok{\# El primer día no llueve}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{2}\SpecialCharTok{:}\NormalTok{nsim)}
\NormalTok{  rx[i] }\OtherTok{\textless{}{-}} \ControlFlowTok{if}\NormalTok{ (rx[i}\DecValTok{{-}1}\NormalTok{]) }\FunctionTok{runif}\NormalTok{(}\DecValTok{1}\NormalTok{) }\SpecialCharTok{\textgreater{}}\NormalTok{ beta }\ControlFlowTok{else} \FunctionTok{runif}\NormalTok{(}\DecValTok{1}\NormalTok{) }\SpecialCharTok{\textless{}}\NormalTok{ alpha}
\end{Highlighting}
\end{Shaded}

Si generamos el gráfico de convergencia asumiendo independencia:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\NormalTok{nsim}
\NormalTok{est }\OtherTok{\textless{}{-}} \FunctionTok{cumsum}\NormalTok{(rx)}\SpecialCharTok{/}\NormalTok{n}
\NormalTok{esterr }\OtherTok{\textless{}{-}} \FunctionTok{sqrt}\NormalTok{(est}\SpecialCharTok{*}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{est)}\SpecialCharTok{/}\NormalTok{(n}\DecValTok{{-}1}\NormalTok{)) }\CommentTok{\# OJO! Supone independencia}
\FunctionTok{plot}\NormalTok{(est, }\AttributeTok{type=}\StringTok{"l"}\NormalTok{, }\AttributeTok{lwd=}\DecValTok{2}\NormalTok{, }\AttributeTok{ylab=}\StringTok{"Probabilidad"}\NormalTok{, }
     \AttributeTok{xlab=}\StringTok{"Número de simulaciones"}\NormalTok{, }\AttributeTok{ylim=}\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\FloatTok{0.6}\NormalTok{))}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{h =}\NormalTok{ est[nsim], }\AttributeTok{lty=}\DecValTok{2}\NormalTok{)}
\FunctionTok{lines}\NormalTok{(est }\SpecialCharTok{+} \DecValTok{2}\SpecialCharTok{*}\NormalTok{esterr, }\AttributeTok{lty=}\DecValTok{2}\NormalTok{) }
\FunctionTok{lines}\NormalTok{(est }\SpecialCharTok{{-}} \DecValTok{2}\SpecialCharTok{*}\NormalTok{esterr, }\AttributeTok{lty=}\DecValTok{2}\NormalTok{)}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{h =} \DecValTok{1}\SpecialCharTok{/}\DecValTok{3}\NormalTok{, }\AttributeTok{col=}\StringTok{"darkgray"}\NormalTok{) }\CommentTok{\# Probabilidad teórica}
\end{Highlighting}
\end{Shaded}

\begin{figure}[!htb]

{\centering \includegraphics[width=0.7\linewidth]{03-Analisis_resultados_files/figure-latex/conv-dep-1} 

}

\caption{Gráfico de convergencia incluyendo el error de la aproximación (calculado asumiendo independencia).}\label{fig:conv-dep}
\end{figure}

La probabilidad teórica, obtenida empleando resultados de cadenas de Markov, es \(p = 1/3\) y la aproximación de la proporción sería correcta (es consistente):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{est[nsim]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.3038
\end{verbatim}

Sin embargo, al ser datos dependientes, la aproximación anterior del error estándar no es adecuada:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{esterr[nsim]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.004599203
\end{verbatim}

En este caso al haber dependencia positiva se produce una subestimación del verdadero error estándar.
Podemos generar el gráfico de autocorrelaciones:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{acf}\NormalTok{(}\FunctionTok{as.numeric}\NormalTok{(rx))}
\end{Highlighting}
\end{Shaded}

\begin{figure}[!htb]

{\centering \includegraphics[width=0.7\linewidth]{03-Analisis_resultados_files/figure-latex/acf-depsec-1} 

}

\caption{Correlograma de la secuencia indicadora de días de lluvia.}\label{fig:acf-depsec}
\end{figure}

El gráfico anterior sugiere que si solo tomamos 1 de cada 25 valores podría ser razonable asumir independencia.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lag }\OtherTok{\textless{}{-}} \DecValTok{24}
\NormalTok{xlag }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\FunctionTok{rep}\NormalTok{(}\ConstantTok{FALSE}\NormalTok{, lag), }\ConstantTok{TRUE}\NormalTok{)}
\NormalTok{rxi }\OtherTok{\textless{}{-}}\NormalTok{ rx[xlag]}
\FunctionTok{acf}\NormalTok{(}\FunctionTok{as.numeric}\NormalTok{(rxi))}
\end{Highlighting}
\end{Shaded}

\begin{figure}[!htb]

{\centering \includegraphics[width=0.7\linewidth]{03-Analisis_resultados_files/figure-latex/acf-depsec2-1} 

}

\caption{Correlograma de la subsecuencia de días de lluvia obtenida seleccionando uno de cada 25 valores.}\label{fig:acf-depsec2}
\end{figure}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nrxi }\OtherTok{\textless{}{-}} \FunctionTok{length}\NormalTok{(rxi)}
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\NormalTok{nrxi}
\NormalTok{est }\OtherTok{\textless{}{-}} \FunctionTok{cumsum}\NormalTok{(rxi)}\SpecialCharTok{/}\NormalTok{n}
\NormalTok{esterr }\OtherTok{\textless{}{-}} \FunctionTok{sqrt}\NormalTok{(est}\SpecialCharTok{*}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{est)}\SpecialCharTok{/}\NormalTok{(n}\DecValTok{{-}1}\NormalTok{))}
\FunctionTok{plot}\NormalTok{(est, }\AttributeTok{type=}\StringTok{"l"}\NormalTok{, }\AttributeTok{lwd=}\DecValTok{2}\NormalTok{, }\AttributeTok{ylab=}\StringTok{"Probabilidad"}\NormalTok{, }
     \AttributeTok{xlab=}\FunctionTok{paste}\NormalTok{(}\StringTok{"Número de simulaciones /"}\NormalTok{, lag }\SpecialCharTok{+} \DecValTok{1}\NormalTok{), }\AttributeTok{ylim=}\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\FloatTok{0.6}\NormalTok{))}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{h =}\NormalTok{ est[}\FunctionTok{length}\NormalTok{(rxi)], }\AttributeTok{lty=}\DecValTok{2}\NormalTok{)}
\FunctionTok{lines}\NormalTok{(est }\SpecialCharTok{+} \DecValTok{2}\SpecialCharTok{*}\NormalTok{esterr, }\AttributeTok{lty=}\DecValTok{2}\NormalTok{) }\CommentTok{\# Supone independencia}
\FunctionTok{lines}\NormalTok{(est }\SpecialCharTok{{-}} \DecValTok{2}\SpecialCharTok{*}\NormalTok{esterr, }\AttributeTok{lty=}\DecValTok{2}\NormalTok{)}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{h =} \DecValTok{1}\SpecialCharTok{/}\DecValTok{3}\NormalTok{, }\AttributeTok{col=}\StringTok{"darkgray"}\NormalTok{)     }\CommentTok{\# Prob. teor. cadenas Markov}
\end{Highlighting}
\end{Shaded}

\begin{figure}[!htb]

{\centering \includegraphics[width=0.7\linewidth]{03-Analisis_resultados_files/figure-latex/conv-dep2-1} 

}

\caption{Gráfico de convergencia de la aproximación de la probabilidad a partir de la subsecuencia de días de lluvia (calculando el error de aproximación asumiendo independencia).}\label{fig:conv-dep2}
\end{figure}

Esta forma de proceder podría ser adecuada para tratar de aproximar la precisión:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{esterr[nrxi]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.02277402
\end{verbatim}

pero no sería eficiente para aproximar la media. Siempre será preferible emplear
todas las observaciones.

Por ejemplo, se podría pensar en considerar las medias de grupos de 24 valores
consecutivos y suponer que hay independencia entre ellas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rxm }\OtherTok{\textless{}{-}} \FunctionTok{rowMeans}\NormalTok{(}\FunctionTok{matrix}\NormalTok{(rx, }\AttributeTok{ncol =}\NormalTok{ lag, }\AttributeTok{byrow =} \ConstantTok{TRUE}\NormalTok{))}
\NormalTok{nrxm }\OtherTok{\textless{}{-}} \FunctionTok{length}\NormalTok{(rxm)}
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\NormalTok{nrxm}
\NormalTok{est }\OtherTok{\textless{}{-}} \FunctionTok{cumsum}\NormalTok{(rxm)}\SpecialCharTok{/}\NormalTok{n}
\NormalTok{esterr }\OtherTok{\textless{}{-}} \FunctionTok{sqrt}\NormalTok{((}\FunctionTok{cumsum}\NormalTok{(rxm}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{)}\SpecialCharTok{/}\NormalTok{n }\SpecialCharTok{{-}}\NormalTok{ est}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{)}\SpecialCharTok{/}\NormalTok{(n}\DecValTok{{-}1}\NormalTok{)) }\CommentTok{\# Errores estándar}
\FunctionTok{plot}\NormalTok{(est, }\AttributeTok{type=}\StringTok{"l"}\NormalTok{, }\AttributeTok{lwd=}\DecValTok{2}\NormalTok{, }\AttributeTok{ylab=}\StringTok{"Probabilidad"}\NormalTok{, }
     \AttributeTok{xlab=}\FunctionTok{paste}\NormalTok{(}\StringTok{"Número de simulaciones /"}\NormalTok{, lag }\SpecialCharTok{+} \DecValTok{1}\NormalTok{), }\AttributeTok{ylim=}\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\FloatTok{0.6}\NormalTok{))}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{h =}\NormalTok{ est[}\FunctionTok{length}\NormalTok{(rxm)], }\AttributeTok{lty=}\DecValTok{2}\NormalTok{)}
\FunctionTok{lines}\NormalTok{(est }\SpecialCharTok{+} \DecValTok{2}\SpecialCharTok{*}\NormalTok{esterr, }\AttributeTok{lty=}\DecValTok{2}\NormalTok{) }\CommentTok{\# OJO! Supone independencia}
\FunctionTok{lines}\NormalTok{(est }\SpecialCharTok{{-}} \DecValTok{2}\SpecialCharTok{*}\NormalTok{esterr, }\AttributeTok{lty=}\DecValTok{2}\NormalTok{)}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{h =} \DecValTok{1}\SpecialCharTok{/}\DecValTok{3}\NormalTok{, }\AttributeTok{col=}\StringTok{"darkgray"}\NormalTok{)     }\CommentTok{\# Prob. teor. cadenas Markov}
\end{Highlighting}
\end{Shaded}

\begin{figure}[!htb]

{\centering \includegraphics[width=0.7\linewidth]{03-Analisis_resultados_files/figure-latex/conv-dep-lotes-1} 

}

\caption{Gráfico de convergencia de las medias por lotes.}\label{fig:conv-dep-lotes}
\end{figure}

Esta es la idea del método de medias por lotes
(\emph{batch means}; \emph{macro-micro replicaciones}) para la estimación de la varianza.
En el ejemplo anterior se calcula el error estándar de la aproximación por simulación de la proporción:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{esterr[nrxm]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.01582248
\end{verbatim}

pero si el objetivo es la aproximación de la varianza (de la variable y no de las medias por lotes), habrá que reescalarlo adecuadamente.
Supongamos que la correlación entre \(X_i\) y \(X_{i+k}\) es aproximadamente nula,
y consideramos las subsecuencias (lotes) \((X_{t+1},X_{t+2},\ldots,X_{t+k})\) con \(t=(j-1)k\), \(j=1,\ldots,m\) y \(n = mk\).
Entonces:

\[\begin{aligned}
Var \left(\bar X \right) &= Var \left(\frac{1}{n} \sum_{i=1}^n X_i\right) 
= Var \left( \frac{1}{m}\sum_{j=1}^m \left(\frac{1}{k} \sum_{t=(i-1)k + 1}^{ik} X_t\right) \right) \\
&\approx \frac{1}{m^2} \sum_{j=1}^m Var \left(\frac{1}{k} \sum_{t=(i-1)k + 1}^{ik} X_t\right)
\approx \frac{1}{m} Var \left(\bar{X}_k \right)
\end{aligned}\]
donde \(\bar{X}_k\) es la media de una subsecuencia de longitud \(k\).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{var.aprox }\OtherTok{\textless{}{-}}\NormalTok{ nsim }\SpecialCharTok{*}\NormalTok{ esterr[}\FunctionTok{length}\NormalTok{(rxm)]}\SpecialCharTok{\^{}}\DecValTok{2}
\NormalTok{var.aprox}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2.50351
\end{verbatim}

Obtenida asumiendo independencia entre las medias por lotes, y que será
una mejor aproximación que asumir independencia entre las generaciones
de la variable:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{var}\NormalTok{(rx)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.2115267
\end{verbatim}

Alternativamente se podría recurrir a la generación de múltiples secuencias
independientes entre sí:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Variable dicotómica 0/1 (FALSE/TRUE)  }
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{nsim }\OtherTok{\textless{}{-}} \DecValTok{1000}
\NormalTok{nsec }\OtherTok{\textless{}{-}} \DecValTok{10}
\NormalTok{alpha }\OtherTok{\textless{}{-}} \FloatTok{0.03} \CommentTok{\# prob de cambio si seco}
\NormalTok{beta }\OtherTok{\textless{}{-}} \FloatTok{0.06}  \CommentTok{\# prob de cambio si lluvia}
\NormalTok{rxm }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\ConstantTok{FALSE}\NormalTok{, }\AttributeTok{nrow =}\NormalTok{ nsec, }\AttributeTok{ncol=}\NormalTok{ nsim)}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\NormalTok{nsec) \{}
  \CommentTok{\# rxm[i, 1] \textless{}{-} FALSE \# El primer día no llueve}
  \CommentTok{\# rxm[i, 1] \textless{}{-} runif(1) \textless{} 1/2 \# El primer día llueve con probabilidad 1/2}
\NormalTok{  rxm[i, }\DecValTok{1}\NormalTok{] }\OtherTok{\textless{}{-}} \FunctionTok{runif}\NormalTok{(}\DecValTok{1}\NormalTok{) }\SpecialCharTok{\textless{}} \DecValTok{1}\SpecialCharTok{/}\DecValTok{3} \CommentTok{\# El primer día llueve con probabilidad 1/3 (ideal)}
  \ControlFlowTok{for}\NormalTok{ (j }\ControlFlowTok{in} \DecValTok{2}\SpecialCharTok{:}\NormalTok{nsim)}
\NormalTok{    rxm[i, j] }\OtherTok{\textless{}{-}} \ControlFlowTok{if}\NormalTok{ (rxm[i, j}\DecValTok{{-}1}\NormalTok{]) }\FunctionTok{runif}\NormalTok{(}\DecValTok{1}\NormalTok{) }\SpecialCharTok{\textgreater{}}\NormalTok{ beta }\ControlFlowTok{else} \FunctionTok{runif}\NormalTok{(}\DecValTok{1}\NormalTok{) }\SpecialCharTok{\textless{}}\NormalTok{ alpha}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

La idea sería considerar las medias de las series como una muestra independiente
de una nueva variable y estimar su varianza de la forma habitual:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Media de cada secuencia}
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\NormalTok{nsim}
\NormalTok{est }\OtherTok{\textless{}{-}} \FunctionTok{apply}\NormalTok{(rxm, }\DecValTok{1}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\FunctionTok{cumsum}\NormalTok{(x)}\SpecialCharTok{/}\NormalTok{n)}
\FunctionTok{matplot}\NormalTok{(n, est, }\AttributeTok{type =} \StringTok{\textquotesingle{}l\textquotesingle{}}\NormalTok{, }\AttributeTok{lty =} \DecValTok{3}\NormalTok{, }\AttributeTok{col =} \StringTok{"lightgray"}\NormalTok{,}
     \AttributeTok{ylab=}\StringTok{"Probabilidad"}\NormalTok{, }\AttributeTok{xlab=}\StringTok{"Número de simulaciones"}\NormalTok{)}
\CommentTok{\# Aproximación}
\NormalTok{mest }\OtherTok{\textless{}{-}} \FunctionTok{apply}\NormalTok{(est, }\DecValTok{1}\NormalTok{, mean)}
\FunctionTok{lines}\NormalTok{(mest, }\AttributeTok{lwd =} \DecValTok{2}\NormalTok{)}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{h =}\NormalTok{ mest[nsim], }\AttributeTok{lty =} \DecValTok{2}\NormalTok{)}
\CommentTok{\# Precisión}
\NormalTok{mesterr }\OtherTok{\textless{}{-}} \FunctionTok{apply}\NormalTok{(est, }\DecValTok{1}\NormalTok{, sd)}\SpecialCharTok{/}\FunctionTok{sqrt}\NormalTok{(nsec)}
\FunctionTok{lines}\NormalTok{(mest }\SpecialCharTok{+} \DecValTok{2}\SpecialCharTok{*}\NormalTok{mesterr, }\AttributeTok{lty =} \DecValTok{2}\NormalTok{)}
\FunctionTok{lines}\NormalTok{(mest }\SpecialCharTok{{-}} \DecValTok{2}\SpecialCharTok{*}\NormalTok{mesterr, }\AttributeTok{lty =} \DecValTok{2}\NormalTok{)}
\CommentTok{\# Prob. teor. cadenas Markov}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{h =} \DecValTok{1}\SpecialCharTok{/}\DecValTok{3}\NormalTok{, }\AttributeTok{col=}\StringTok{"darkgray"}\NormalTok{)     }
\end{Highlighting}
\end{Shaded}

\begin{figure}[!htb]

{\centering \includegraphics[width=0.7\linewidth]{03-Analisis_resultados_files/figure-latex/conv-dep-nsec-1} 

}

\caption{Gráfico de convergencia de la media de 10 secuencias generadas de forma independiente.}\label{fig:conv-dep-nsec}
\end{figure}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Aproximación final}
\NormalTok{mest[nsim] }\CommentTok{\# mean(rxm)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.3089
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Error estándar}
\NormalTok{mesterr[nsim]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.02403491
\end{verbatim}

Trataremos este tipo de problemas en la diagnosis de algoritmos de
simulación Monte Carlo de Cadenas de Markov (MCMC).
Aparecen también en la simulación dinámica (por eventos o cuantos).

\hypertarget{periodo-de-calentamiento}{%
\subsection{Periodo de calentamiento}\label{periodo-de-calentamiento}}

En el caso de simulación de datos dependientes (simulación dinámica)
pueden aparecer problemas de estabilización. Puede ocurrir que el sistema
evolucione lentamente en el tiempo hasta alcanzar su distribución estacionaria,
siendo muy sensible a las condiciones iniciales con las que se comienzó la
simulación. En tal caso resulta conveniente ignorar los resultados obtenidos
durante un cierto período inicial de tiempo (denominado período de calentamiento
o estabilización), cuyo único objeto es conseguir que se estabilice la distribución de
probabilidad.

Como ejemplo comparamos la simulación del Ejemplo \ref{exm:mmc} con la obtenida considerando como punto de partida un día lluvioso (con una semilla distinta para evitar dependencia).

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\NormalTok{nsim }\OtherTok{\textless{}{-}} \DecValTok{10000}
\NormalTok{rx2 }\OtherTok{\textless{}{-}} \FunctionTok{logical}\NormalTok{(nsim)}
\NormalTok{rx2[}\DecValTok{1}\NormalTok{] }\OtherTok{\textless{}{-}} \ConstantTok{TRUE} \CommentTok{\# El primer día llueve}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{2}\SpecialCharTok{:}\NormalTok{nsim)}
\NormalTok{  rx2[i] }\OtherTok{\textless{}{-}} \ControlFlowTok{if}\NormalTok{ (rx2[i}\DecValTok{{-}1}\NormalTok{]) }\FunctionTok{runif}\NormalTok{(}\DecValTok{1}\NormalTok{) }\SpecialCharTok{\textgreater{}}\NormalTok{ beta }\ControlFlowTok{else} \FunctionTok{runif}\NormalTok{(}\DecValTok{1}\NormalTok{) }\SpecialCharTok{\textless{}}\NormalTok{ alpha}
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\NormalTok{nsim}
\NormalTok{est }\OtherTok{\textless{}{-}} \FunctionTok{cumsum}\NormalTok{(rx)}\SpecialCharTok{/}\NormalTok{n}
\NormalTok{est2 }\OtherTok{\textless{}{-}} \FunctionTok{cumsum}\NormalTok{(rx2)}\SpecialCharTok{/}\NormalTok{n}
\FunctionTok{plot}\NormalTok{(est, }\AttributeTok{type=}\StringTok{"l"}\NormalTok{, }\AttributeTok{ylab=}\StringTok{"Probabilidad"}\NormalTok{, }
     \AttributeTok{xlab=}\StringTok{"Número de simulaciones"}\NormalTok{, }\AttributeTok{ylim=}\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\FloatTok{0.6}\NormalTok{))}
\FunctionTok{lines}\NormalTok{(est2, }\AttributeTok{lty =} \DecValTok{2}\NormalTok{)}
\CommentTok{\# Ejemplo periodo calentamiento nburn = 2000}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{v =} \DecValTok{2000}\NormalTok{, }\AttributeTok{lty =} \DecValTok{3}\NormalTok{)}
\CommentTok{\# Prob. teor. cadenas Markov}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{h =} \DecValTok{1}\SpecialCharTok{/}\DecValTok{3}\NormalTok{, }\AttributeTok{col=}\StringTok{"darkgray"}\NormalTok{)     }
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{03-Analisis_resultados_files/figure-latex/unnamed-chunk-17-1} \end{center}

En estos casos puede ser recomendable ignorar los primeros valores generados (por ejemplo los primeros 2000) y recalcular los
estadísticos deseados.

También trataremos este tipo de problemas en la diagnosis de algoritmos MCMC.

\begin{example}[simulación de un proceso autorregresivo, serie de tiempo]
\protect\hypertarget{exm:unnamed-chunk-18}{}{\label{exm:unnamed-chunk-18} \iffalse (simulación de un proceso autorregresivo, serie de tiempo) \fi{} }
\end{example}

\[X_t = \mu + \rho * (X_{t-1} - \mu) + \varepsilon_t\]
Podemos tener en cuenta que en este caso la varianza es:
\[\textrm{var}(X_t)=\operatorname{E}(X_t^2)-\mu^2=\frac{\sigma_\varepsilon^2}{1-\rho^2}.\]

Establecemos los parámetros:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nsim }\OtherTok{\textless{}{-}} \DecValTok{200}   \CommentTok{\# Numero de simulaciones}
\NormalTok{xmed }\OtherTok{\textless{}{-}} \DecValTok{0}     \CommentTok{\# Media}
\NormalTok{rho }\OtherTok{\textless{}{-}} \FloatTok{0.5}    \CommentTok{\# Coeficiente AR}
\NormalTok{nburn }\OtherTok{\textless{}{-}} \DecValTok{10}   \CommentTok{\# Periodo de calentamiento (burn{-}in)}
\end{Highlighting}
\end{Shaded}

Se podría fijar la varianza del error:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{evar }\OtherTok{\textless{}{-}} \DecValTok{1}
\CommentTok{\# Varianza de la respuesta}
\NormalTok{xvar }\OtherTok{\textless{}{-}}\NormalTok{ evar }\SpecialCharTok{/}\NormalTok{ (}\DecValTok{1} \SpecialCharTok{{-}}\NormalTok{ rho}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

pero la recomendación sería fijar la varianza de la respuesta:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{xvar }\OtherTok{\textless{}{-}} \DecValTok{1}     
\CommentTok{\# Varianza del error}
\NormalTok{evar }\OtherTok{\textless{}{-}}\NormalTok{ xvar}\SpecialCharTok{*}\NormalTok{(}\DecValTok{1} \SpecialCharTok{{-}}\NormalTok{ rho}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Para simular la serie, al ser un \(AR(1)\), normalmente simularíamos el primer valor

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rx[}\DecValTok{1}\NormalTok{] }\OtherTok{\textless{}{-}} \FunctionTok{rnorm}\NormalTok{(}\DecValTok{1}\NormalTok{, }\AttributeTok{mean =}\NormalTok{ xmed, }\AttributeTok{sd =} \FunctionTok{sqrt}\NormalTok{(xvar))}
\end{Highlighting}
\end{Shaded}

o lo fijamos a la media (en este caso nos alejamos un poco de la distribución estacionaria, para que el ``periodo de calentamiento'' sea mayor).
Después generamos los siguientes valores de forma recursiva:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{numeric}\NormalTok{(nsim }\SpecialCharTok{+}\NormalTok{ nburn)}
\CommentTok{\# Establecer el primer valor }
\NormalTok{x[}\DecValTok{1}\NormalTok{] }\OtherTok{\textless{}{-}} \SpecialCharTok{{-}}\DecValTok{10}
\CommentTok{\# Simular el resto de la secuencia}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{2}\SpecialCharTok{:}\FunctionTok{length}\NormalTok{(x))}
\NormalTok{  x[i] }\OtherTok{\textless{}{-}}\NormalTok{ xmed }\SpecialCharTok{+}\NormalTok{ rho}\SpecialCharTok{*}\NormalTok{(x[i}\DecValTok{{-}1}\NormalTok{] }\SpecialCharTok{{-}}\NormalTok{ xmed) }\SpecialCharTok{+} \FunctionTok{rnorm}\NormalTok{(}\DecValTok{1}\NormalTok{, }\AttributeTok{sd=}\FunctionTok{sqrt}\NormalTok{(evar))}
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{as.ts}\NormalTok{(x)}
\FunctionTok{plot}\NormalTok{(x)}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{v =}\NormalTok{ nburn, }\AttributeTok{lty =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[!htb]

{\centering \includegraphics[width=0.7\linewidth]{03-Analisis_resultados_files/figure-latex/sim-ar1-1} 

}

\caption{Ejemplo de una simulación de una serie de tiempo autorregresiva.}\label{fig:sim-ar1}
\end{figure}

y eliminamos el periodo de calentamiento:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rx }\OtherTok{\textless{}{-}}\NormalTok{ x[}\SpecialCharTok{{-}}\FunctionTok{seq\_len}\NormalTok{(nburn)]}
\end{Highlighting}
\end{Shaded}

Para simular una serie de tiempo en R se puede emplear la función \texttt{arima.sim} del paquete base \texttt{stats}.
En este caso el periodo de calentamiento se establece mediante el parámetro \texttt{n.start} (que se fija automáticamente a un valor adecuado).

Por ejemplo, podemos generar este serie autoregressiva con:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rx2 }\OtherTok{\textless{}{-}} \FunctionTok{arima.sim}\NormalTok{(}\FunctionTok{list}\NormalTok{(}\AttributeTok{order =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{), }\AttributeTok{ar =}\NormalTok{ rho), }\AttributeTok{n =}\NormalTok{ nsim, }
                 \AttributeTok{n.start =}\NormalTok{ nburn, }\AttributeTok{sd =} \FunctionTok{sqrt}\NormalTok{(evar))}
\end{Highlighting}
\end{Shaded}

La recomendación es fijar la varianza de las series simuladas si se quieren comparar
resultados considerando distintos parámetros de dependencia.

\hypertarget{observaciones}{%
\section{Observaciones}\label{observaciones}}

Como comentarios finales, podríamos añadir que:

\begin{itemize}
\item
  En el caso de que la característica de interés de la distribución de \(X\) no sea la media, los resultados anteriores no serían en principio aplicables.
\item
  Incluso en el caso de la media, con el CLT obtenemos intervalos de confianza puntuales, que no habría que confundir con \emph{bandas de confianza} (es muy probable que no contengan el verdadero valor del parámetro en todo el rango).
\item
  En muchos casos (por ejemplo, cuando la generación de múltiples secuencias de simulación supone un coste computacional importante), puede ser preferible emplear un método de remuestreo para aproximar la precisión de la aproximación (ver Sección \ref{bootstrap}).
\end{itemize}

\hypertarget{referencias}{%
\chapter*{Referencias}\label{referencias}}
\addcontentsline{toc}{chapter}{Referencias}

\textbf{Bibliografía básica}

Cao, R. (2002). \emph{Introducción a la simulación y a la teoría de colas}. NetBiblo.

Cao R. y Fernández-Casal R. (2020). \emph{Técnicas de Remuestreo}. \url{https://rubenfcasal.github.io/book_remuestreo}.

Gentle, J.E. (2003). \emph{Random number generation and Monte Carlo methods}. Springer‐Verlag.

Jones, O. et al.~(2009). \emph{Introduction to Scientific Programming and Simulation Using R}. CRC.

Ripley, B.D. (1987). \emph{Stochastic Simulation}. John Wiley \& Sons.

Robert, C.P. y G. Casella (2010). \emph{Introducing Monte Carlo Methods with R}. Springer.

Ross, S.M. (1999).\emph{Simulación}. Prentice Hall.

Suess, E.A. y Trumbo, B.E. (2010). \emph{Introduction to probability simulation and Gibbs sampling with R}. Springer.

\hypertarget{bibliografuxeda-complementaria}{%
\section*{Bibliografía complementaria}\label{bibliografuxeda-complementaria}}
\addcontentsline{toc}{section}{Bibliografía complementaria}

\hypertarget{libros}{%
\subsection*{Libros}\label{libros}}
\addcontentsline{toc}{subsection}{Libros}

Azarang, M. R. y García Dunna, E. (1996). \emph{Simulación y análisis de modelos estocásticos}. McGraw-Hill.

Bratley, P., Fox, B.L. y Schrage L.E. (1987). \emph{A guide to simulation}. Springer-Verlag.

Davison, A.C. y Hinkley, D.V. (1997). \emph{Bootstrap Methods and Their Application}. Cambridge University Press.

Devroye, L. (1986). \emph{Non-uniform random variate generation}. Springer-Verlag.

Evans, M. y Swartz, T. (2000). \emph{Approximating integrals via Monte Carlo and determinstic methods}. Oxford University Press.

Gentle, J.E. (1998). \emph{Random number generation and Monte Carlo methods}. Springer-Verlag.

Hyndman, R.J. y Athanasopoulos, G. (2018). \emph{Forecasting: principles and practice}. OTexts.
Disponible online: \href{https://otexts.com/fpp2}{2nd edition (forecast)}, \href{https://otexts.com/fpp3}{3rd edition (fable)}.

Hofert, M. (2018). \emph{Elements of Copula Modeling with R}, Springer.

Hörmann, W. et al.~(2004). \emph{Automatic Nonuniform Random Variate Generation}. Springer.

Knuth, D.E. (1969). \emph{The Art of Computer Programming}. Volume 2. Addison-Wesley.

Knuth, D.E. (2002). \emph{The Art of Computer Programming}. Volume 2, third edition, ninth printing. Addison-Wesley.

Law, A.M. y Kelton, W.D. (1991). \emph{Simulation, modeling and analysis}. McGraw-Hill.

Liu, J.S. (2004). \emph{Monte Carlo strategies in scientific computing}. Springer.

Moeschlin, O., Grycko, E., Pohl, C. y Steinert, F. (1998). \emph{Experimental stochastics}. Springer-Verlag.

Nelsen, R.B. (2006). \emph{An introduction to copulas}, 2ª ed., Springer.

Nelson, R. (1995). \emph{Probability, stochastic processes, and queueing theory: the mathematics of computer performance modelling}. Springer-Verlag.

Pardo, L. y Valdés, T. (1987). \emph{Simulación. Aplicaciones prácticas a la empresa}. Díaz de Santos.

Robert, C.P. y G. Casella (2004). \emph{Monte Carlo statistical methods}. Springer.
Shao, J. (2003). \emph{Mathematical statistics}. Springer.

\hypertarget{artuxedculos}{%
\subsection*{Artículos}\label{artuxedculos}}
\addcontentsline{toc}{subsection}{Artículos}

Demirhan, H. y Bitirim, N. (2016). \href{https://journal.r-project.org/archive/2016/RJ-2016-016/index.html}{CryptRndTest: an R package for testing the cryptographic randomness}. \emph{The R Journal}, 8(1), 233-247.

Downham, D.Y. (1970). Algorithm AS 29: The runs up and down test. \emph{Journal of the Royal Statistical Society}. Series C (Applied Statistics), 19(2), 190-192.

Gilks, W.R. y Wild, P. (1992). Adaptive rejection sampling for Gibbs sampling. \emph{Journal of the Royal Statistical Society}. Series C (Applied Statistics), 41(2), 337-348.

Kinderman, A.J. y Monahan, J.F. (1977). Computer generation of random variables using the ratio of uniform deviates. \emph{ACM Transactions on Mathematical Software (TOMS)}, 3(3), 257-260.

L'Ecuyer, P. (1999). Good parameters and implementations for combined multiple recursive random number generators. \emph{Operations Research}, 47, 159--164.

L'Ecuyer, P. y Simard, R. (2007). TestU01: A C library for empirical testing of random number generators. \emph{ACM Transactions on Mathematical Software} (TOMS), 33(4), 1-40.

Marsaglia, G. y Tsang, W.W. (2002). \href{http://www.jstatsoft.org/v07/i03}{Some difficult-to-pass tests of randomness}. \emph{Journal of Statistical Software}, 7(3), 1-9.

Marsaglia, G., Zaman, A. y Tsang, W.W. (1990). Toward a universal random number generator. \emph{Stat. Prob. Lett.}, 9(1), 35-39.

Matsumoto, M. y Nishimura, T. (1998). Mersenne Twister: A 623-dimensionally equidistributed uniform pseudo-random number generator, \emph{ACM Transactions on Modeling and Computer Simulation}, 8, 3--30.

Odeh, R.E. y Evans, J.O. (1974). The percentage points of the normal distribution. \emph{Journal of the Royal Statistical Society}. Series C (Applied Statistics), 23(1), 96-97.

Patefield, W.M. (1981). \href{https://doi.org/10.2307/2346669}{Algorithm AS 159: An efficient method of generating random r x c tables with given row and column totals}. \emph{Applied Statistics}, 30, 91--97.

Park, S.K. y Miller , K.W. (1988). Random number generators: good ones are hard to find. \emph{Communications of the ACM}, 31(10), 1192-1201.

Park, S.K., Miller, K.W. y Stockmeyer, P.K. (1993). Technical correspondence. \emph{Communications of the ACM}, 36(7), 108-110.

Wichura, M.J. (1988) Algorithm AS 241: The Percentage Points of the Normal Distribution. \emph{Applied Statistics}, 37, 477--484.

\hypertarget{appendix-apendices}{%
\appendix}


\hypertarget{links}{%
\chapter{Enlaces}\label{links}}

\begin{itemize}
\item
  \textbf{\emph{Repositorio}}: \href{https://github.com/rubenfcasal/simbook}{rubenfcasal/simbook}
\item
  \textbf{Recursos para el aprendizaje de R}: En este \href{https://rubenfcasal.github.io/post/ayuda-y-recursos-para-el-aprendizaje-de-r}{post} se muestran algunos recursos que pueden ser útiles para el aprendizaje de R y la obtención de ayuda.
\item
  \href{https://bookdown.org}{\textbf{\emph{Bookdown}}}:

  \begin{itemize}
  \item
    \href{https://rubenfcasal.github.io/book_remuestreo}{Técnicas de Remuestreo}
    (\href{https://github.com/rubenfcasal/book_remuestreo}{github}).
  \item
    \href{https://rubenfcasal.github.io/bookdown_intro/rmarkdown.html}{Introducción a RMarkdown}
  \item
    Advanced R:
    \href{http://adv-r.had.co.nz/}{1ª ed},
    \href{https://adv-r.hadley.nz/}{2ª ed}
  \item
    \href{http://r-pkgs.had.co.nz/}{R packages}
  \end{itemize}
\end{itemize}

\hypertarget{gof-aleat}{%
\chapter{Bondad de Ajuste y Aleatoriedad}\label{gof-aleat}}

En los métodos clásicos de inferencia estadística es habitual asumir que los valores observados \(X_1,\ldots, X_n\) (o los errores de un modelo) constituyen una muestra aleatoria simple de una variable aleatoria \(X\).
Se están asumiendo por tanto dos hipótesis estructurales: la independencia (aleatoriedad) y la homogeneidad (misma distribución) de las observaciones (o de los errores).
Adicionalmente, en inferencia paramétrica se supone que la distribución se ajusta a un modelo
paramétrico específico \(F_{\theta}(x)\), siendo \(\theta\) un parámetro que normalmente es desconocido.

Uno de los objetivos de la inferencia no paramétrica es desarrollar herramientas que permitan verificar el grado de cumplimiento de las hipótesis anteriores\footnote{
  El otro objetivo de la inferencia estadística no paramétrica es desarrollar procedimientos alternativos (métodos de distribución libre) que sean válidos cuando no se verifica alguna de las hipótesis estructurales.}.
Los procedimientos habituales incluyen métodos descriptivos (principalmente gráficos), contrastes de bondad de ajuste (también de homogeneidad o de datos atípicos) y contrastes de aleatoriedad.

En este apéndice se describen brevemente algunos de los métodos clásicos, principalmente con la idea de que pueden ser de utilidad para evaluar resultados de simulación y para la construcción de modelos del sistema real (e.g.~para modelar variables que se tratarán como entradas del modelo general). Se empleará principalmente el enfoque de la estadística no paramétrica, aunque también se mostrarán algunas pequeñas diferencias entre su uso en inferencia y en simulación.

Los métodos genéricos no son muy adecuados para evaluar generadores aleatorios (e.g.~L'Ecuyer y Simard, 2007).
La recomendación sería emplear baterías de contrastes recientes, como las descritas en la Sección \ref{baterias}.
No obstante, en la última sección se describirán, únicamente con fines ilustrativos, algunos de los primeros métodos diseñados específicamente para generadores aleatorios.

\hypertarget{gof}{%
\section{Métodos de bondad de ajuste}\label{gof}}

A partir de \(X_1,\ldots,X_n\) m.a.s. de \(X\) con función de
distribución \(F\), interesa realizar un contraste de la forma:
\[\left \{
\begin{array}{l}
H_0:F=F_0\\
H_1:F\neq F_0
\end{array}
\right.\]

En este caso interesará distinguir principalmente entre hipótesis nulas simples (especifican un único modelo) y compuestas (especifican un conjunto o familia de modelos).
Por ejemplo:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.43}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.53}}@{}}
\toprule
\(H_0\) simple & \(H_0\) compuesta \\
\midrule
\endhead
\(\left \{ \begin{array}{l} H_0:F= \mathcal{N}(0,1)\\ H_1:F\neq \mathcal{N}(0,1) \end{array} \right.\) & \(\left \{ \begin{array}{l} H_0:F= \mathcal{N}(\mu,\sigma^2)\\ H_1:F\neq \mathcal{N}(\mu,\sigma^2) \end{array} \right.\) \\
\bottomrule
\end{longtable}

Entre los métodos gráficos habituales estarían: histograma, gráfico de la densidad suavizada, gráfico de tallo y hojas, gráfico de la distribución empírica (o versión suavizada) y gráficos P-P o Q-Q.

Entre los métodos de contrastes de hipótesis generales (\(H_0:F=F_0\)) destacarían las pruebas: Chi-cuadrado de Pearson, Kolmogorov-Smirnov, Cramer-von Mises o Anderson-Darling.
Además de los específicos de normalidad (\(H_0:F= \mathcal{N}(\mu,\sigma^2)\)): Kolmogorov-Smirnov-Lilliefors, Shapiro-Wilks y los de asimetría y apuntamiento.

\hypertarget{histograma}{%
\subsection{Histograma}\label{histograma}}

Se agrupan los datos en intervalos \(I_{k}=\left[ L_{k-1},L_{k}\right)\) con \(k=1, \ldots, K\) y a cada intervalo se le asocia un valor (altura de la barra) igual a la frecuencia absoluta de ese intervalo \(n_k = \sum_{i=1}^{n}\mathbf{1}\left( X_i \in [L_{k-1},L_{k}) \right)\), si la longitud de los intervalos es constante, o proporcional a dicha frecuencia (de forma que el área coincida con la frecuencia relativa y pueda ser comparado con una función de densidad):
\[\hat{f}_n(x)=\frac{n_{i}}{n\left(  L_{k}-L_{k-1}\right)}\]

Como ya se ha visto anteriormente, en R podemos generar este gráfico con la función \texttt{hist()} del paquete base.
Algunos de los principales parámetros (con los valores por defecto) son los siguientes:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{hist}\NormalTok{(x, }\AttributeTok{breaks =} \StringTok{"Sturges"}\NormalTok{, }\AttributeTok{freq =} \ConstantTok{NULL}\NormalTok{, }\AttributeTok{plot =} \ConstantTok{TRUE}\NormalTok{, ...)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\item
  \texttt{breaks}: puede ser un valor numérico con el número de puntos de discretización, un vector con los puntos de discretización, una cadena de texto que los determine (otras opciones son \texttt{"Scott"} y \texttt{"FD"}; en este caso llamará internamente a la función \texttt{nclass.xxx()} donde \texttt{xxx} se corresponde con la cadena de texto), o incluso una función personalizada que devuelva el número o el vector de puntos de discretización.
\item
  \texttt{freq}: lógico (\texttt{TRUE} por defecto si los puntos de discretización son equidistantes), determina si en el gráfico se representan frecuencias o ``densidades''.
\item
  \texttt{plot}: lógico, se puede establecer a \texttt{FALSE} si no queremos generar el gráfico y solo nos interesan el objeto con los resultados (que devuelve de forma ``invisible'', por ejemplo para discretizar los valores en intervalos).
\end{itemize}

Ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datos }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\FloatTok{22.56}\NormalTok{,}\FloatTok{22.33}\NormalTok{,}\FloatTok{24.58}\NormalTok{,}\FloatTok{23.14}\NormalTok{,}\FloatTok{19.03}\NormalTok{,}\FloatTok{26.76}\NormalTok{,}\FloatTok{18.33}\NormalTok{,}\FloatTok{23.10}\NormalTok{,}
  \FloatTok{21.53}\NormalTok{,}\FloatTok{9.06}\NormalTok{,}\FloatTok{16.75}\NormalTok{,}\FloatTok{23.29}\NormalTok{,}\FloatTok{22.14}\NormalTok{,}\FloatTok{16.28}\NormalTok{,}\FloatTok{18.89}\NormalTok{,}\FloatTok{27.48}\NormalTok{,}\FloatTok{10.44}\NormalTok{,}
  \FloatTok{26.86}\NormalTok{,}\FloatTok{27.27}\NormalTok{,}\FloatTok{18.74}\NormalTok{,}\FloatTok{19.88}\NormalTok{,}\FloatTok{15.76}\NormalTok{,}\FloatTok{30.77}\NormalTok{,}\FloatTok{21.16}\NormalTok{,}\FloatTok{24.26}\NormalTok{,}\FloatTok{22.90}\NormalTok{,}
  \FloatTok{27.14}\NormalTok{,}\FloatTok{18.02}\NormalTok{,}\FloatTok{21.53}\NormalTok{,}\FloatTok{24.99}\NormalTok{,}\FloatTok{19.81}\NormalTok{,}\FloatTok{11.88}\NormalTok{,}\FloatTok{24.01}\NormalTok{,}\FloatTok{22.11}\NormalTok{,}\FloatTok{21.91}\NormalTok{,}
  \FloatTok{14.35}\NormalTok{,}\FloatTok{11.14}\NormalTok{,}\FloatTok{9.93}\NormalTok{,}\FloatTok{20.22}\NormalTok{,}\FloatTok{17.73}\NormalTok{,}\FloatTok{19.05}\NormalTok{)}
\FunctionTok{hist}\NormalTok{(datos, }\AttributeTok{freq =} \ConstantTok{FALSE}\NormalTok{)}
\FunctionTok{curve}\NormalTok{(}\FunctionTok{dnorm}\NormalTok{(x, }\FunctionTok{mean}\NormalTok{(datos), }\FunctionTok{sd}\NormalTok{(datos)), }\AttributeTok{add =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{22-Bondad_ajuste_Aleatoriedad_files/figure-latex/unnamed-chunk-3-1} \end{center}

Si el número de valores es muy grande (por ejemplo en el caso de secuencias aleatorias), nos puede interesar establecer la opción \texttt{breaks\ =\ "FD"} para aumentar el número de intervalos de discretización.
En cualquier caso, como se muestra en la Figura \ref{fig:hist-movie}, la convergencia del histograma a la densidad teórica se podría considerar bastante lenta.
Alternativamente se podría considerar una estimación suave de la densidad, por ejemplo empleando la estimación tipo núcleo implementada en la función \texttt{density()}.

\begin{figure}[!htb]

{\centering \includegraphics[width=0.7\linewidth]{22-Bondad_ajuste_Aleatoriedad_files/figure-latex/hist-movie-1} 

}

\caption{Convergencia del histograma a la densidad teórica.}\label{fig:hist-movie}
\end{figure}

\hypertarget{empdistr}{%
\subsection{Función de distribución empírica}\label{empdistr}}

La función de distribución empírica \(F_n\left( x \right)=\frac{1}{n}\sum_{i=1}^{n}\mathbf{1}\left( X_i\leq x\right)\) asigna a cada número real \(x\) la frecuencia relativa de observaciones menores o iguales que \(x\).
Para obtener las frecuencias relativas acumuladas, se ordena la muestra \(X_{(1)}\leq X_{(2)}\leq \cdots \leq X_{(n)}\) y:
\[F_n(x)=\left \{
\begin{array}{cll}
0 & \text{si } &x<X_{\left(  1\right)  }\\
\tfrac{i}n & \text{si } & X_{\left(  i\right)  }\leq x<X_{\left(  i+1\right)  }\\
1 & \text{si } & X_{\left(  n\right)  }\leq x
\end{array}
\right.\]

Ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fn }\OtherTok{\textless{}{-}} \FunctionTok{ecdf}\NormalTok{(datos)}
\FunctionTok{curve}\NormalTok{(}\FunctionTok{ecdf}\NormalTok{(datos)(x), }\AttributeTok{xlim =} \FunctionTok{extendrange}\NormalTok{(datos), }\AttributeTok{type =} \StringTok{\textquotesingle{}s\textquotesingle{}}\NormalTok{, }
      \AttributeTok{ylab =} \StringTok{\textquotesingle{}distribution function\textquotesingle{}}\NormalTok{, }\AttributeTok{lwd =} \DecValTok{2}\NormalTok{)}
\FunctionTok{curve}\NormalTok{(}\FunctionTok{pnorm}\NormalTok{(x, }\FunctionTok{mean}\NormalTok{(datos), }\FunctionTok{sd}\NormalTok{(datos)), }\AttributeTok{add =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[!htb]

{\centering \includegraphics[width=0.7\linewidth]{22-Bondad_ajuste_Aleatoriedad_files/figure-latex/ecdfplot-1} 

}

\caption{Comparación de la distribución empírica de los datos de ejemplo con la función de distribución de la aproximación normal.}\label{fig:ecdfplot}
\end{figure}

\hypertarget{gruxe1ficos-p-p-y-q-q}{%
\subsection{Gráficos P-P y Q-Q}\label{gruxe1ficos-p-p-y-q-q}}

El gráfico de probabilidad (o de probabilidad-probabilidad) es el gráfico de dispersión de:
\[\left \{  \left( F_0(x_{i}), F_n(x_{i}) \right)  :i=1,\cdots,n\right \}\]
siendo \(F_n\) la función de distribución empírica y \(F_0\) la función de distribución bajo \(H_0\) (con la que desea comparar, si la hipótesis nula es simple) o una estimación bajo \(H_0\) (si la hipótesis nula es compuesta; e.g.~si \(H_0:F= \mathcal{N}(\mu,\sigma^2)\),
\(\hat{F}_0\) función de distribución de \(\mathcal{N}(\hat{\mu},\hat{\sigma}^2)\)).
Si \(H_0\) es cierta, la nube de puntos estará en torno a la recta \(y=x\) (probabilidades observadas próximas a las esperadas bajo \(H_0\)).

El gráfico Q-Q (cuantil-cuantil) es equivalente al anterior pero en la escala de la variable:
\[\left\{ \left( q_{i}, x_{(i)}\right) : i=1, \cdots, n \right\}\]
siendo \(x_{(i)}\) los cuantiles observados y \(q_{i}=F_0^{-1}(p_{i})\) los esperados\footnote{Típicamente \(\left \{ p_{i}=\frac{\left(i-0.5 \right)}n : i=1, \cdots, n \right\}\).} bajo \(H_0\).

Ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{qqnorm}\NormalTok{(datos)}
\FunctionTok{qqline}\NormalTok{(datos)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{22-Bondad_ajuste_Aleatoriedad_files/figure-latex/unnamed-chunk-4-1} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{require}\NormalTok{(car)}
\FunctionTok{qqPlot}\NormalTok{(datos, }\StringTok{"norm"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{22-Bondad_ajuste_Aleatoriedad_files/figure-latex/unnamed-chunk-4-2} \end{center}

\begin{verbatim}
## [1] 10 38
\end{verbatim}

\hypertarget{chi2test}{%
\subsection{Contraste chi-cuadrado de Pearson}\label{chi2test}}

Se trata de un contraste de bondad de ajuste:
\[\left \{
\begin{array}{l}
H_0:F=F_0\\
H_1:F\neq F_0\end{array}
\right.\]
desarrollado inicialmente para variables categóricas. En el caso general, podemos pensar que los datos están agrupados en \(k\) clases: \(C_1,\cdots,C_{k}\). Por ejemplo, si la variable es categórica o discreta, cada clase se puede corresponder con una modalidad. Si la variable es continua habrá que categorizarla en intervalos.

Si la hipótesis nula es simple, cada clase tendrá asociada una probabilidad \(p_{i}=P\left( X\in C_{i} \right)\) bajo \(H_0\) . Si por el contrario es compuesta, se trabajará con una estimación de dicha probabilidad (y habrá que correguir la distribución aproximada del estadístico del contraste).

\begin{longtable}[]{@{}lllll@{}}
\toprule
Clases & Discreta & Continua & \(H_0\) simple & \(H_0\) compuesta \\
\midrule
\endhead
\(C_1\) & \(x_1\) & \([L_0,L_1)\) & \(p_1\) & \(\hat{p}_1\) \\
\(\vdots\) & \(\vdots\) & \(\vdots\) & \(\vdots\) & \(\vdots\) \\
\(C_{k}\) & \(x_{k}\) & \([L_{k-1},L_{k})\) & \(p_{k}\) & \(\hat{p}_{k}\) \\
& & & \(\sum_{i}p_{i}=1\) & \(\sum_{i}\hat{p}_{i}=1\) \\
\bottomrule
\end{longtable}

Se realizará un contraste equivalente:
\[\left\{ \begin{array}[c]{l}
H_0:\text{Las probabilidades son correctas}\\
H_1:\text{Las probabilidades no son correctas}
\end{array} \right.\]

Si \(H_0\) es cierta, la frecuencia relativa \(f_{i}\) de la clase \(C_{i}\) es una aproximación de la probabilidad teórica, \(f_{i}\approx p_{i}\).
Equivalentemente, las frecuencias observadas \(n_{i}=n\cdot f_{i}\) deberían ser próximas a las esperadas \(e_{i}=n\cdot p_{i}\) bajo \(H_0\), sugiriendo el estadístico del contraste (Pearson, 1900):
\[\chi^2=\sum_{i=1}^{k}\frac{(n_{i}-e_{i})^2}{e_{i}}\underset{aprox.}{\sim
}\chi_{k-r-1}^2,\text{ si }H_0\text{ cierta}\]
siendo \(k\) el número de clases y \(r\) el número de parámetros estimados (para aproximar las probabilidades bajo \(H_0\)).

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.07}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.20}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.20}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.20}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.34}}@{}}
\toprule
Clases & \(n_{i}\) observadas & \(p_{i}\) bajo \(H_0\) & \(e_{i}\) bajo \(H_0\) & \(\frac{(n_{i}-e_{i})^2}{e_{i}}\) \\
\midrule
\endhead
\(C_1\) & \(n_1\) & \(p_1\) & \(e_1\) & \(\frac{(n_1-e_1)^2}{e_1}\) \\
\(\vdots\) & \(\vdots\) & \(\vdots\) & \(\vdots\) & \(\vdots\) \\
\(C_{k}\) & \(n_{k}\) & \(p_{k}\) & \(e_{k}\) & \(\frac{(n_{k}-e_{k})^2}{e_{k}}\) \\
Total & \(\sum_{i}n_{i}=n\) & \(\sum_{i}p_{i}=1\) & \(\sum_{i}e_{i}=n\) & \(\chi^2=\sum_{i=1}^{k}\frac{(n_{i}-e_{i})^2}{e_{i}}\) \\
\bottomrule
\end{longtable}

Cuando \(H_0\) es cierta el estadístico tiende a tomar valores pequeños y grandes cuando es falsa.
Por tanto se rechaza \(H_0\), para un nivel de significación \(\alpha\), si:
\[\sum_{i=1}^{k}\frac{(n_{i}-e_{i})^2}{e_{i}}\geq \chi_{k-r-1,1-\alpha}^2\]

Si realizamos el contraste a partir del p-valor o nivel crítico:
\[p=P\left(  {\chi_{k-r-1}^2\geq \sum \limits_{i=1}^{k}{\frac{(n_{i}-e_{i})^2}{e_{i}}}}\right)\]
rechazaremos \(H_0\) si \(p\leq \alpha\) (y cuanto menor sea se rechazará con mayor seguridad) y aceptaremos \(H_0\) si \(p>\) \(\alpha\) (con mayor seguridad cuanto mayor sea).

Este método está implementado en la función \texttt{chisq.test()} para el caso discreto (no corrige los grados de libertad).
Ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{trunc}\NormalTok{(}\DecValTok{5} \SpecialCharTok{*} \FunctionTok{runif}\NormalTok{(}\DecValTok{100}\NormalTok{))}
\FunctionTok{chisq.test}\NormalTok{(}\FunctionTok{table}\NormalTok{(x))            }\CommentTok{\# NOT \textquotesingle{}chisq.test(x)\textquotesingle{}!}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##  Chi-squared test for given probabilities
## 
## data:  table(x)
## X-squared = 9.2, df = 4, p-value = 0.05629
\end{verbatim}

La distribución exacta del estadístico del contraste es discreta (se podría aproximar por simulación, por ejemplo empleando los parámetros \texttt{simulate.p.value\ =\ TRUE} y \texttt{B\ =\ 2000} de la función \texttt{chisq.test()}; ver también el Ejercicio \ref{exr:chicuadind} de la Sección \ref{simconting} para el caso del contraste chi-cuadrado de independencia).
Para que la aproximación continua \(\chi^2\) sea válida:

\begin{itemize}
\item
  El tamaño muestral debe ser suficientemente grande (p.e. \(n>30\)).
\item
  La muestra debe ser una muestra aleatoria simple.
\item
  Los parámetros deben estimarse (si es necesario) por máxima
  verosimilitud.
\item
  Las frecuencias esperadas \(e_{i}=n\cdot p_{i}\) deberían ser todas
  \(\geq5\) (realmente esta es una restricción conservadora, la aproximación
  puede ser adecuada si no hay frecuencias esperadas inferiores a 1 y
  menos de un 20\% inferiores a 5).
\end{itemize}

Si la frecuencia esperada de alguna clase es \(<5\), se suele agrupar con otra
clase (o con varias si no fuese suficiente con una) para obtener una
frecuencia esperada \(\geq5\):

\begin{itemize}
\item
  Cuando la variable es nominal (no hay una ordenación lógica) se
  suele agrupar con la(s) que tiene(n) menor valor de \(e_{i}\).
\item
  Si la variable es ordinal (o numérica) debe juntarse la que causó el
  problema con una de las adyacentes.
\end{itemize}

Si la variable de interés es continua, una forma de garantizar que \(e_{i}\geq5\) consiste en tomar un número de intervalos \(k\leq \lfloor n/5 \rfloor\) y de forma que sean equiprobables \(p_{i}=1/k\),
considerando los puntos críticos \(x_{i/k}\) de la distribución bajo \(H_0\).

Por ejemplo, se podría emplear la función \texttt{simres::chisq.cont.test()} (fichero \href{R/test.R}{\emph{test.R}}), que imita a las incluidas en R:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{simres}\SpecialCharTok{::}\NormalTok{chisq.cont.test}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## function(x, distribution = "norm", nclass = floor(length(x)/5),
##                             output = TRUE, nestpar = 0, ...) {
##   # Función distribución
##   q.distrib <- eval(parse(text = paste("q", distribution, sep = "")))
##   # Puntos de corte
##   q <- q.distrib((1:(nclass - 1))/nclass, ...)
##   tol <- sqrt(.Machine$double.eps)
##   xbreaks <- c(min(x) - tol, q, max(x) + tol)
##   # Gráficos y frecuencias
##   if (output) {
##     xhist <- hist(x, breaks = xbreaks, freq = FALSE,
##                   lty = 2, border = "grey50")
##     # Función densidad
##     d.distrib <- eval(parse(text = paste("d", distribution, sep = "")))
##     curve(d.distrib(x, ...), add = TRUE)
##   } else {
##     xhist <- hist(x, breaks = xbreaks, plot = FALSE)
##   }
##   # Cálculo estadístico y p-valor
##   O <- xhist$counts  # Equivalente a table(cut(x, xbreaks)) pero más eficiente
##   E <- length(x)/nclass
##   DNAME <- deparse(substitute(x))
##   METHOD <- "Pearson's Chi-squared test"
##   STATISTIC <- sum((O - E)^2/E)
##   names(STATISTIC) <- "X-squared"
##   PARAMETER <- nclass - nestpar - 1
##   names(PARAMETER) <- "df"
##   PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)
##   # Preparar resultados
##   classes <- format(xbreaks)
##   classes <- paste("(", classes[-(nclass + 1)], ",", classes[-1], "]",
##                    sep = "")
##   RESULTS <- list(classes = classes, observed = O, expected = E,
##                   residuals = (O - E)/sqrt(E))
##   if (output) {
##     cat("\nPearson's Chi-squared test table\n")
##     print(as.data.frame(RESULTS))
##   }
##   if (any(E < 5))
##     warning("Chi-squared approximation may be incorrect")
##   structure(c(list(statistic = STATISTIC, parameter = PARAMETER, p.value = PVAL,
##                    method = METHOD, data.name = DNAME), RESULTS), class = "htest")
## }
## <bytecode: 0x00000000403f18f0>
## <environment: namespace:simres>
\end{verbatim}

Continuando con el ejemplo anterior, podríamos contrastar normalidad mediante:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{chisq.cont.test}\NormalTok{(datos, }\AttributeTok{distribution =} \StringTok{"norm"}\NormalTok{, }\AttributeTok{nestpar =} \DecValTok{2}\NormalTok{, }\AttributeTok{mean=}\FunctionTok{mean}\NormalTok{(datos), }\AttributeTok{sd=}\FunctionTok{sd}\NormalTok{(datos))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{22-Bondad_ajuste_Aleatoriedad_files/figure-latex/unnamed-chunk-7-1} \end{center}

\begin{verbatim}
## 
## Pearson's Chi-squared test table
##               classes observed expected  residuals
## 1 ( 9.06000,14.49908]        6    5.125  0.3865103
## 2 (14.49908,16.94725]        3    5.125 -0.9386680
## 3 (16.94725,18.77800]        4    5.125 -0.4969419
## 4 (18.77800,20.41732]        6    5.125  0.3865103
## 5 (20.41732,22.05663]        4    5.125 -0.4969419
## 6 (22.05663,23.88739]        8    5.125  1.2699625
## 7 (23.88739,26.33556]        4    5.125 -0.4969419
## 8 (26.33556,30.77000]        6    5.125  0.3865103
\end{verbatim}

\begin{verbatim}
## 
##  Pearson's Chi-squared test
## 
## data:  datos
## X-squared = 3.6829, df = 5, p-value = 0.5959
\end{verbatim}

\hypertarget{ks-test}{%
\subsection{Contraste de Kolmogorov-Smirnov}\label{ks-test}}

Se trata de un contraste de bondad de ajuste diseñado para distribuciones continuas
(similar a la prueba de Cramer-von Mises o a la de Anderson-Darling, implementadas en el paquete \texttt{goftest} de R, que son en principio mejores).
Se basa en comparar la función de distribución \(F_0\) bajo \(H_0\) con la función de distribución empírica \(F_n\):
\[\begin{aligned}
& D_n=\sup_{x}|F_n(x)-F_0(x)|,\\
& = \max_{1 \leq i \leq n} \left\{ |F_n(X_{(i)})-F_0(X_{(i)})|,|F_n(X_{(i-1)})-F_0(X_{(i)})| \right\}
\end{aligned}\]

Teniendo en cuenta que \(F_n\left( X_{(i)}\right) = \frac{i}n\):
\[\begin{aligned}
D_n  & =\max_{1\leq i\leq n}\left \{  \frac{i}n-F_0(X_{(i)}),F_0(X_{(i)})-\frac{i-1}n\right \} \\
& =\max_{1\leq i\leq n}\left \{  D_{n,i}^{+},D_{n,i}^{-}\right \}
\end{aligned}\]

Si \(H_0\) es simple y \(F_0\) es continua, la distribución del estadístico \(D_n\) bajo \(H_0\) no depende \(F_0\) (es de distribución libre).
Esta distribución está tabulada (para tamaños muestrales grandes se utiliza la aproximación asintótica).
Se rechaza \(H_0\) si el valor observado \(d\) del estadístico es significativamente grande:
\[p = P \left( D_n \geq d \right) \leq \alpha.\]
Este método está implementado en la función \texttt{ks.test()} del paquete base de R:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ks.test}\NormalTok{(x, y, ...)}
\end{Highlighting}
\end{Shaded}

donde \texttt{x} es un vector que contiene los datos, \texttt{y} es una función de distribución
(o una cadena de texto que la especifica; también puede ser otro vector de datos
para el contraste de dos muestras) y \texttt{...} representa los parámetros de la distribución.

Continuando con el ejemplo anterior, para contrastar \(H_0:F= \mathcal{N}(20,5^2)\) podríamos emplear:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ks.test}\NormalTok{(datos, pnorm, }\AttributeTok{mean =} \DecValTok{20}\NormalTok{, }\AttributeTok{sd =} \DecValTok{5}\NormalTok{) }\CommentTok{\# One{-}sample }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##  One-sample Kolmogorov-Smirnov test
## 
## data:  datos
## D = 0.13239, p-value = 0.4688
## alternative hypothesis: two-sided
\end{verbatim}

Si \(H_0\) es compuesta, el procedimiento habitual es estimar los parámetros desconocidos
por máxima verosimilitud y emplear \(\hat{F}_0\) en lugar de \(F_0\).
Sin embargo, al proceder de esta forma es de esperar que \(\hat{F}_0\) se aproxime más
que \(F_0\) a la distribución empírica, por lo que los cuantiles de la distribución de
\(D_n\) pueden ser demasiado conservativos (los \(p\)-valores tenderán a ser mayores de
lo que deberían) y se tenderá a aceptar la hipótesis nula (puede ser preferible aproximar el \(p\)-valor mediante simulación; como se muestra en el Ejercicio \ref{exr:ks-test-sim} de la Sección \ref{contrastes}).

Para evitar este problema, en el caso de contrastar normalidad se desarrolló el test
de Lilliefors, implementado en la función \texttt{lillie.test()} del paquete \texttt{nortest}
(también hay versiones en este paquete para los métodos de Cramer-von Mises y
Anderson-Darling).

Por ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ks.test}\NormalTok{(datos, pnorm, }\FunctionTok{mean}\NormalTok{(datos), }\FunctionTok{sd}\NormalTok{(datos)) }\CommentTok{\# One{-}sample Kolmogorov{-}Smirnov test}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##  One-sample Kolmogorov-Smirnov test
## 
## data:  datos
## D = 0.097809, p-value = 0.8277
## alternative hypothesis: two-sided
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(nortest)}
\FunctionTok{lillie.test}\NormalTok{(datos)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##  Lilliefors (Kolmogorov-Smirnov) normality test
## 
## data:  datos
## D = 0.097809, p-value = 0.4162
\end{verbatim}

\hypertarget{diag-aleat}{%
\section{Diagnosis de la independencia}\label{diag-aleat}}

Los métodos ``clásicos'' de inferencia estadística se basan en
suponer que las observaciones \(X_{1},\ldots,X_{n}\) son una muestra
aleatoria simple (m.a.s.) de \(X\). Por tanto suponen que
las observaciones son independientes (o los errores, en el caso de un
modelo de regresión).

\begin{itemize}
\item
  La ausencia de aleatoriedad es difícil de corregir y puede influir
  notablemente en el análisis estadístico.
\item
  Si existe dependencia entre las observaciones muestrales (e.g.
  el conocimiento de \(X_{i}\) proporciona información sobre los valores
  de \(X_{i+1}\), \(X_{i+2}\), \(\ldots\)), los métodos ``clásicos'' no serán
  en principio adecuados (pueden conducir a conclusiones erróneas).

  \begin{itemize}
  \item
    Esto es debido principalmente a que introduce un sesgo en los
    estimadores de las varianzas (diseñados asumiendo independencia).
  \item
    Los correspondientes intervalos de confianza y
    contrastes de hipótesis tendrán una confianza o una potencia
    distinta de la que deberían (aunque las estimaciones de los parámetros
    pueden no verse muy afectadas).
  \end{itemize}
\end{itemize}

Si \(X_{1}\) e \(X_{2}\) son independientes (\(Cov(X_{1},X_{2})=0\)):
\[Var(X_{1}+X_{2})=Var(X_{1})+Var(X_{2})\]

En el caso general (dependencia):
\[Var(X_{1}+X_{2})=Var(X_{1})+Var(X_{2})+2Cov(X_{1},X_{2})\]

Típicamente \(Cov(X_{1},X_{2})>0\) por lo que con los métodos
``clásicos'' (basados en independencia) se suelen producir
subestimaciones de las varianzas (IC más estrechos y tendencia a
rechazar \(H_{0}\) en contrastes).

\textbf{Ejemplo}: datos simulados

Consideramos un proceso temporal estacionario con dependencia exponencial
(la dependencia entre las observaciones depende del ``salto'' entre ellas;
ver Ejemplo \ref{exm:funcional} en la Sección \ref{fact-cov}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{100}          \CommentTok{\# Nº de observaciones}
\NormalTok{t }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\AttributeTok{length =}\NormalTok{ n)}
\NormalTok{mu }\OtherTok{\textless{}{-}} \FunctionTok{rep}\NormalTok{(}\DecValTok{0}\NormalTok{, n)   }\CommentTok{\# Media}
\CommentTok{\# mu \textless{}{-} 0.25 + 0.5*t}
\CommentTok{\# mu \textless{}{-} sin(2*pi*t)}

\CommentTok{\# Matriz de covarianzas}
\NormalTok{t.dist }\OtherTok{\textless{}{-}} \FunctionTok{as.matrix}\NormalTok{(}\FunctionTok{dist}\NormalTok{(t))}
\NormalTok{t.cov }\OtherTok{\textless{}{-}} \FunctionTok{exp}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{t.dist)}
\CommentTok{\# str(t.cov)}
\CommentTok{\# num [1:100, 1:100] 1 0.99 0.98 0.97 0.96 ...}

\CommentTok{\# Simulación de las observaciones}
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\FunctionTok{library}\NormalTok{(MASS)}

\NormalTok{z }\OtherTok{\textless{}{-}} \FunctionTok{rnorm}\NormalTok{(n)}
\NormalTok{x1 }\OtherTok{\textless{}{-}}\NormalTok{ mu }\SpecialCharTok{+}\NormalTok{ z }\CommentTok{\# Datos independientes}
\NormalTok{x2 }\OtherTok{\textless{}{-}} \FunctionTok{mvrnorm}\NormalTok{(}\DecValTok{1}\NormalTok{, mu, t.cov) }\CommentTok{\# Datos dependientes}

\FunctionTok{plot}\NormalTok{(t, mu, }\AttributeTok{type=}\StringTok{"l"}\NormalTok{, }\AttributeTok{lwd =} \DecValTok{2}\NormalTok{, }\AttributeTok{ylim =} \FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{3}\NormalTok{,}\DecValTok{3}\NormalTok{), }\AttributeTok{ylab =} \StringTok{\textquotesingle{}x\textquotesingle{}}\NormalTok{)}
\FunctionTok{lines}\NormalTok{(t, x1, }\AttributeTok{col =} \StringTok{\textquotesingle{}blue\textquotesingle{}}\NormalTok{)}
\FunctionTok{lines}\NormalTok{(t, x2, }\AttributeTok{col =} \StringTok{\textquotesingle{}red\textquotesingle{}}\NormalTok{)}
\FunctionTok{legend}\NormalTok{(}\StringTok{"bottomright"}\NormalTok{, }\AttributeTok{legend =} \FunctionTok{c}\NormalTok{(}\StringTok{"Datos independientes"}\NormalTok{, }\StringTok{"Datos dependientes"}\NormalTok{), }\AttributeTok{col =} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}blue\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}red\textquotesingle{}}\NormalTok{), }\AttributeTok{lty =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{22-Bondad_ajuste_Aleatoriedad_files/figure-latex/unnamed-chunk-11-1} \end{center}

En el caso anterior la varianza es uno con ambos procesos.
Las estimaciones suponiendo independencia serían:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{var}\NormalTok{(x1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.8067621
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{var}\NormalTok{(x2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.1108155
\end{verbatim}

En el caso de datos dependientes se produce una clara subestimación de la varianza

\hypertarget{muxe9todos-para-detectar-dependencia}{%
\subsection{Métodos para detectar dependencia}\label{muxe9todos-para-detectar-dependencia}}

Es de esperar que datos cercanos en el tiempo (o en el espacio)
sean más parecidos (dependientes) que datos más alejados, hablaríamos entonces de dependencia temporal (espacial o espacio-temporal).

En esta sección nos centraremos en el caso de dependencia temporal (unidimensional).
Entre los métodos para detectar este tipo de dependencia destacaríamos:

\begin{itemize}
\item
  Gráficos:

  \begin{itemize}
  \item
    Secuencial / Dispersión frente al tiempo
  \item
    Dispersión retardado
  \item
    Correlograma
  \end{itemize}
\item
  Contrastes:

  \begin{itemize}
  \item
    Tests basados en rachas
  \item
    Test de Ljung-Box
  \end{itemize}
\end{itemize}

\hypertarget{gruxe1fico-secuencial}{%
\subsection{Gráfico secuencial}\label{gruxe1fico-secuencial}}

El gráfico de dispersión \(\{(i,X_{i}) : i = 1, \ldots, n \}\) permite detectar la presencia de un efecto temporal (en la tendencia o en la variabilidad).

\begin{itemize}
\item
  Es importante mantener/guardar el orden de recogida de los datos.
\item
  Si existe una tendencia los datos no son homogéneos (debería tenerse
  en cuenta la variable índice, o tiempo, como variable explicativa).
  Podría indicar la presencia de un ``efecto aprendizaje''.
\item
  Comandos R: \texttt{plot(as.ts(x))}
\end{itemize}

Ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{old.par }\OtherTok{\textless{}{-}} \FunctionTok{par}\NormalTok{(}\AttributeTok{mfrow =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{))}
\FunctionTok{plot}\NormalTok{(datos, }\AttributeTok{type =} \StringTok{\textquotesingle{}l\textquotesingle{}}\NormalTok{)}
\FunctionTok{plot}\NormalTok{(}\FunctionTok{as.ts}\NormalTok{(datos))}
\end{Highlighting}
\end{Shaded}

\begin{figure}[!htb]

{\centering \includegraphics[width=0.7\linewidth]{22-Bondad_ajuste_Aleatoriedad_files/figure-latex/grafsec-1} 

}

\caption{Ejemplos de gráficos secuenciales.}\label{fig:grafsec}
\end{figure}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{par}\NormalTok{(old.par)}
\end{Highlighting}
\end{Shaded}

Es habitual que este tipo de análisis se realice sobre los residuos
de un modelo de regresión (e.g.~\texttt{datos\ \textless{}-\ residuals(modelo)})

Este gráfico también podría servir para detectar dependencia temporal:

\begin{itemize}
\item
  Valores próximos muy parecidos (valores grandes seguidos de grandes
  y viceversa) indicarían una posible dependencia positiva.
\item
  Valores próximos dispares (valores grandes seguidos de pequeños
  y viceversa) indicarían una posible dependencia negativa.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{old.par }\OtherTok{\textless{}{-}} \FunctionTok{par}\NormalTok{(}\AttributeTok{mfrow =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{))}
\FunctionTok{plot}\NormalTok{(x2, }\AttributeTok{type =} \StringTok{\textquotesingle{}l\textquotesingle{}}\NormalTok{, }\AttributeTok{ylab =} \StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{, }\AttributeTok{main =} \StringTok{\textquotesingle{}Dependencia positiva\textquotesingle{}}\NormalTok{)}
\FunctionTok{plot}\NormalTok{(x1, }\AttributeTok{type =} \StringTok{\textquotesingle{}l\textquotesingle{}}\NormalTok{, }\AttributeTok{ylab =} \StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{, }\AttributeTok{main =} \StringTok{\textquotesingle{}Independencia\textquotesingle{}}\NormalTok{)}
\NormalTok{x3 }\OtherTok{\textless{}{-}}\NormalTok{ x2 }\SpecialCharTok{*} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{)}
\FunctionTok{plot}\NormalTok{(x3, }\AttributeTok{type =} \StringTok{\textquotesingle{}l\textquotesingle{}}\NormalTok{, }\AttributeTok{ylab =} \StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{, }\AttributeTok{main =} \StringTok{\textquotesingle{}Dependencia negativa\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{22-Bondad_ajuste_Aleatoriedad_files/figure-latex/unnamed-chunk-13-1} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{par}\NormalTok{(old.par)}
\end{Highlighting}
\end{Shaded}

pero suele ser preferible emplear un gráfico de dispersión retardado.

\hypertarget{gruxe1fico-de-dispersion-retardado}{%
\subsection{Gráfico de dispersion retardado}\label{gruxe1fico-de-dispersion-retardado}}

El gráfico de dispersión \(\{(X_{i},X_{i+1}) : i = 1, \ldots, n-1 \}\) permite
detectar dependencias a un retardo (relaciones entre valores separados
por un instante)

\begin{itemize}
\tightlist
\item
  Comando R:\texttt{plot(x{[}-length(x){]},\ x{[}-1{]},\ xlab\ =\ "X\_t",\ ylab\ =\ "X\_t+1")}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{old.par }\OtherTok{\textless{}{-}} \FunctionTok{par}\NormalTok{(}\AttributeTok{mfrow =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{))}
\FunctionTok{plot}\NormalTok{(x2[}\SpecialCharTok{{-}}\FunctionTok{length}\NormalTok{(x2)], x2[}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{], }\AttributeTok{xlab =} \StringTok{"X\_t"}\NormalTok{, }\AttributeTok{ylab =} \StringTok{"X\_t+1"}\NormalTok{, }\AttributeTok{main =} \StringTok{\textquotesingle{}Dependencia positiva\textquotesingle{}}\NormalTok{)}
\FunctionTok{plot}\NormalTok{(x1[}\SpecialCharTok{{-}}\FunctionTok{length}\NormalTok{(x1)], x1[}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{], }\AttributeTok{xlab =} \StringTok{"X\_t"}\NormalTok{, }\AttributeTok{ylab =} \StringTok{"X\_t+1"}\NormalTok{, }\AttributeTok{main =} \StringTok{\textquotesingle{}Independencia\textquotesingle{}}\NormalTok{)}
\FunctionTok{plot}\NormalTok{(x3[}\SpecialCharTok{{-}}\FunctionTok{length}\NormalTok{(x3)], x3[}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{], }\AttributeTok{xlab =} \StringTok{"X\_t"}\NormalTok{, }\AttributeTok{ylab =} \StringTok{"X\_t+1"}\NormalTok{, }\AttributeTok{main =} \StringTok{\textquotesingle{}Dependencia negativa\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{22-Bondad_ajuste_Aleatoriedad_files/figure-latex/unnamed-chunk-14-1} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{par}\NormalTok{(old.par)}
\end{Highlighting}
\end{Shaded}

Se puede generalizar al gráfico \(\{(X_{i},X_{i+k}) : i = 1, \ldots, n-k \}\)
que permite detectar dependencias a \(k\) retardos
(separadas \(k\) instantes).

\textbf{Ejemplo}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Gráfico de dispersion retardado}
\FunctionTok{plot}\NormalTok{(datos[}\SpecialCharTok{{-}}\FunctionTok{length}\NormalTok{(datos)], datos[}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{], }\AttributeTok{xlab =} \StringTok{"X\_t"}\NormalTok{, }\AttributeTok{ylab =} \StringTok{"X\_t+1"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{22-Bondad_ajuste_Aleatoriedad_files/figure-latex/unnamed-chunk-15-1} \end{center}

El correspondiente coeficiente de correlación es una medida numérica
del grado de relación lineal (denominado autocorrelación de orden 1).

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cor}\NormalTok{(datos[}\SpecialCharTok{{-}}\FunctionTok{length}\NormalTok{(datos)], datos[}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.01344127
\end{verbatim}

\textbf{Ejemplo}: Calidad de un generador aleatorio

En el caso de una secuencia muy grande de número pseudoaleatorios (supuestamente independientes), sería muy dificil distinguir un patrón a partir del gráfico anterior. La recomendación en R sería utilizar puntos con color de relleno:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{plot}\NormalTok{(u[}\SpecialCharTok{{-}}\FunctionTok{length}\NormalTok{(u)], u[}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{], }\AttributeTok{xlab=}\StringTok{"U\_t"}\NormalTok{, }\AttributeTok{ylab=}\StringTok{"U\_t+1"}\NormalTok{, }\AttributeTok{pch=}\DecValTok{21}\NormalTok{, }\AttributeTok{bg=}\StringTok{"white"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[!htb]

{\centering \includegraphics[width=0.7\linewidth]{22-Bondad_ajuste_Aleatoriedad_files/figure-latex/dispret-1} 

}

\caption{Ejemplos de gráficos de dispensión retardados de dos secuencias de longitud 10000.}\label{fig:dispret}
\end{figure}

Si se observa algún tipo de patrón indicaría dependencia (se podría considerar como una versión descriptiva del denominado ``Parking lot test'').
Se puede generalizar también a \(d\)-uplas \((X_{t+1},X_{t+2},\ldots,X_{t+d})\)
(ver ejemplo del generador RANDU en Figura \ref{fig:randu} de la Sección \ref{gen-cong}).

\hypertarget{el-correlograma}{%
\subsection{El correlograma}\label{el-correlograma}}

Para estudiar si el grado de relación (lineal) entre \(X_{i}\) e
\(X_{i+k}\) podemos utilizar el coeficiente de correlación:

\[\rho\left(  X_{i},X_{i+k}\right) = \frac{Cov\left(  X_{i},X_{i+k}\right)    }
{\sigma\left(  X_{i}\right)  \sigma\left(  X_{i+k}\right)  }\]

\begin{itemize}
\item
  En el caso de datos homogéneos (estacionarios) la correlación sería función únicamente del salto:
  \[\rho\left(  X_{i},X_{i+k}\right)  \equiv\rho\left(  k\right)\]
  denominada función de autocorrelación simple (fas) o correlograma.
\item
  Su estimador es el correlograma muestral:
  \[r(k)=\frac{\sum_{i=1}^{n-k}(X_{i}-\overline{X})(X_{i+k}-\overline{X})}
  {\sum_{i=1}^{n}(X_{i}-\overline{X})^{2}}\]
\item
  Comando R:\texttt{acf(x)}
\end{itemize}

En caso de independencia es de esperar que las autocorrelaciones
muestrales sean próximas a cero (valores ``grandes'' indicarían
dependencia positiva o negativa según el signo).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{old.par }\OtherTok{\textless{}{-}} \FunctionTok{par}\NormalTok{(}\AttributeTok{mfrow =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{))}
\FunctionTok{acf}\NormalTok{(x1, }\AttributeTok{main =} \StringTok{\textquotesingle{}Independencia\textquotesingle{}}\NormalTok{)}
\FunctionTok{acf}\NormalTok{(x2, }\AttributeTok{main =} \StringTok{\textquotesingle{}Dependencia positiva\textquotesingle{}}\NormalTok{)}
\FunctionTok{acf}\NormalTok{(x3, }\AttributeTok{main =} \StringTok{\textquotesingle{}Dependencia negativa\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{22-Bondad_ajuste_Aleatoriedad_files/figure-latex/unnamed-chunk-18-1} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{par}\NormalTok{(old.par)}
\end{Highlighting}
\end{Shaded}

Suponiendo normalidad e independencia, asintóticamente:
\[r(k)\underset{aprox.}{\sim}N\left(  \rho(k),\frac{1}{n}\right)\]

\begin{itemize}
\item
  Si el tamaño muestral es grande, podríamos aceptar \(H_{0}:\)
  \(\rho\left( k\right) = 0\) si:\[|r(k)|<\dfrac{2}{\sqrt{n}}\]
\item
  En el \emph{gráfico de autocorrelaciones muestrales} (también
  denominado correlograma) se representan las estimaciones \(r(k)\)
  de las autocorrelaciones correspondientes a los primeros retardos
  (típicamente \(k<n/4\)) y las correspondientes bandas de confianza
  (para detectar dependencias significativas).
\end{itemize}

\textbf{Ejemplo}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{acf}\NormalTok{(datos)  }\CommentTok{\# correlaciones}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{22-Bondad_ajuste_Aleatoriedad_files/figure-latex/unnamed-chunk-19-1} \end{center}

La función \texttt{acf} también permite estimar el covariograma\footnote{En algunos campos, como en estadística espacial, en lugar del covariograma se suele emplear el semivariograma \(\gamma(k) = C(0) - C(k)\).}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{covar }\OtherTok{\textless{}{-}} \FunctionTok{acf}\NormalTok{(x2, }\AttributeTok{type =} \StringTok{"covariance"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{22-Bondad_ajuste_Aleatoriedad_files/figure-latex/unnamed-chunk-20-1} \end{center}

\hypertarget{test-de-rachas}{%
\subsection{Test de rachas}\label{test-de-rachas}}

Permite contrastar si el orden de aparición de dos valores de una
variable dicotómica es aleatorio.
Supongamos que \(X\) toma los valores \(+\) y \(-\)
y que observamos una muestra del tipo:
\[++++---+++--++++++----\]
y nos interesa contrastar:

\[\left\{ \begin{array}[c]{l}
    H_{0}:\mathit{La\ muestra\ es\ aleatoria}\\
    H_{1}:\mathit{La\ muestra\ no\ es\ aleatoria}
\end{array}
\right.\]

Una \emph{racha} es una secuencia de observaciones iguales (o
similares):
\[\underbrace{++++}_{1}\underbrace{---}_{2}\underbrace{+++}_{3}
\underbrace{--}_{4}\underbrace{++++++}_{5}\underbrace{----}_{6}\]

\begin{itemize}
\item
  Una muestra con ``muchas'' o ``pocas'' rachas sugeriría que la muestra
  no es aleatoria (con dependencia negativa o positiva, respec.).
\item
  Estadístico del contraste:
  \[R=\text{"Número total de rachas en la muestra"}\]
\item
  Bajo la hipótesis nula de aleatoriedad:
  \[R\underset{aprox.}{\sim}N\left(  1+\frac{2n_{1}n_{2}}{n},
  \frac{2n_{1}n_{2}(2n_{1}n_{2}-n)}{n^{2}(n-1)}\right)\]
  siendo \(n_{1}\) y \(n_{2}\) el número de signos \(+\) y \(-\) en la muestra,
  respectivamente (\(n_{1}+n_{2}=n\)).
  Para tamaños muéstrales pequeños (\(n<40\)), esta aproximación
  no es buena y conviene utilizar la distribución exacta (o utilizar
  corrección por continuidad). Los valores críticos de esta
  distribución están tabulados.
\end{itemize}

Este contraste se emplea también para variables continuas, se fija
un punto de corte para dicotomizarlas. Normalmente se toma como punto de corte la mediana.

\begin{itemize}
\item
  En este caso si \(k=n_{1}\) (\(\simeq n_{2}\)):
  \[R\underset{aprox.}{\sim}N\left(  k+1,\frac{k(k-1)}{2k-1}\right)\]
\item
  Se rechaza la hipótesis nula de aleatoriedad si el número de rachas
  es significativamente pequeño o grande.
\item
  Si el tamaño muestral es grande, el \(p\)-valor será:
  \[p \simeq 2 P\left( Z \geq \left\vert 
  \frac{R-E(R)}{\sqrt{Var(R)}} \right\vert \right)\]
\item
  Comandos R: \texttt{tseries::runs.test(as.factor(x\ \textgreater{}\ median(x)))}
\end{itemize}

\textbf{Ejemplo}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tseries)}
\FunctionTok{runs.test}\NormalTok{(}\FunctionTok{as.factor}\NormalTok{(datos }\SpecialCharTok{\textgreater{}} \FunctionTok{median}\NormalTok{(datos)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##  Runs Test
## 
## data:  as.factor(datos > median(datos))
## Standard Normal = -0.4422, p-value = 0.6583
## alternative hypothesis: two.sided
\end{verbatim}

Alternativamente, para evitar el cálculo del punto de corte (la mediana), requerido para dicotomizar la variable continua, se podría emplear una modificación de este contraste, el denominado test de rachas ascendentes y descendentes, en el que se generan los valores \(+\) y \(-\) dependiendo de si el valor de la secuencia es mayor o menor que el anterior (ver e.g.~Downham, 1970). Este contraste es más adecuado para generadores aleatorios.

\hypertarget{el-contraste-de-ljung-box}{%
\subsection{El contraste de Ljung-Box}\label{el-contraste-de-ljung-box}}

Es un test muy utilizado (en series de tiempo) para contrastar la
hipótesis de independencia.
Se contrasta la hipótesis nula de que las primeras \(m\)
autocorrelaciones son cero:
\[\left\{\begin{array}[c]{l}
    H_{0}:\rho_{1}=\rho_{2}=\ldots=\rho_{m}=0\\
    H_{1}:\rho_{i}\neq0\text{ para algún } i
\end{array}
\right.\]

\begin{itemize}
\item
  Se elige un \(m\) tal que la estimación \(r(m)\) de
  \(\rho_{m}=\rho(m)\) sea ``fiable'' (e.g.~\(10\log_{10}n\)).
\item
  El estadístico del contraste:
  \[Q=n(n+2)\sum_{k=1}^{m}\frac{r(k)^{2}}{n-k}\underset{aprox.}{\sim}\chi
  _{m}^{2}\text{, si }H_{0}\text{ es cierta.}\]
\item
  Se rechaza \(H_{0}\) si el valor observado es grande (\(Q\geq \chi_{m,1-\alpha}^{2}\)):
  \[p=P\left(  {\chi_{m}^{2}}\geq Q\right)\]
\item
  Comandos R:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
    \FunctionTok{Box.test}\NormalTok{(x, }\AttributeTok{type=}\NormalTok{Ljung)}
    \FunctionTok{Box.test}\NormalTok{(x, lag, }\AttributeTok{type=}\NormalTok{Ljung)}
\end{Highlighting}
\end{Shaded}

\textbf{Ejemplo}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Box.test}\NormalTok{(datos, }\AttributeTok{type=}\StringTok{"Ljung"}\NormalTok{) }\CommentTok{\# Contrasta si la primera autocorrelación es nula }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##  Box-Ljung test
## 
## data:  datos
## X-squared = 0.0078317, df = 1, p-value = 0.9295
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Box.test}\NormalTok{(datos, }\AttributeTok{lag=}\DecValTok{5}\NormalTok{, }\AttributeTok{type=}\StringTok{"Ljung"}\NormalTok{) }\CommentTok{\# Contrasta si las 5 primeras autocorrelaciones son nulas}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##  Box-Ljung test
## 
## data:  datos
## X-squared = 1.2556, df = 5, p-value = 0.9394
\end{verbatim}

NOTA: Cuando se trabaja con residuos de un modelo lineal, para contrastar que la primera autocorrelación es cero, es preferible emplear el test de
Durbin-Watson implementado en la función \texttt{dwtest()} del paquete \texttt{lmtest}.

\hypertarget{contrastes-especuxedficos-para-generadores-aleatorios}{%
\section{Contrastes específicos para generadores aleatorios}\label{contrastes-especuxedficos-para-generadores-aleatorios}}

Los contrastes generales anteriores pueden ser muy poco adecuados para testear generadores de números pseudoaleatorios (ver e.g.~L'Ecuyer y Simard, 2007). Por ese motivo se han desarrollado contrastes específicos, principalmente con el objetivo de encontrar un generador con buenas propiedades criptográficas.

Muchos de estos contrastes están basados en la prueba chi-cuadrado y trabajan con enteros en lugar de los valores uniformes. El procedimiento habitual consiste en fijar un entero positivo \(K\), y discretizar los valores uniformes \(U_{1},U_{2},\ldots,U_{n}\), de la forma:
\[X_i = \left\lfloor K\cdot U_{i}\right\rfloor + 1 ,\]
donde \(\left\lfloor u\right\rfloor\) denota la parte entera de \(u\).
De esta forma se consigue una sucesión de enteros aleatorios supuestamente independientes con distribución uniforme en \(\{1, \ldots, K\}\).

En esta sección se describirán algunos de los métodos tradicionales en este campo con fines ilustrativos. Si realmente el objetivo es diagnosticar la calidad de un generador, la recomendación sería emplear las baterías de contrastes más recientes descritas en la Sección \ref{baterias}.

\hypertarget{freq-test}{%
\subsection{Contraste de frecuencias}\label{freq-test}}

Empleando la discretización anterior se simplifica notablemente el contraste chi-cuadrado de bondad de ajuste a una uniforme, descrito en la Sección \ref{chi2test} e implementado en la función \texttt{chisq.cont.test()}.
En este caso bastaría con contrastar la equiprobabilidad de la secuencia de enteros (empleando directamente la función \texttt{chisq.test()}) y este método de denomina \emph{contraste de frecuencias} (frequency test).
Por ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Generar}
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{u }\OtherTok{\textless{}{-}} \FunctionTok{runif}\NormalTok{(}\DecValTok{1000}\NormalTok{)}
\CommentTok{\# Discretizar}
\NormalTok{k }\OtherTok{\textless{}{-}} \DecValTok{10}
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{floor}\NormalTok{(k}\SpecialCharTok{*}\NormalTok{u) }\SpecialCharTok{+} \DecValTok{1}
\CommentTok{\# Test chi{-}cuadrado}
\NormalTok{f }\OtherTok{\textless{}{-}} \FunctionTok{table}\NormalTok{(}\FunctionTok{factor}\NormalTok{(x, }\AttributeTok{levels =} \FunctionTok{seq\_len}\NormalTok{(k)))}
\FunctionTok{chisq.test}\NormalTok{(f)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##  Chi-squared test for given probabilities
## 
## data:  f
## X-squared = 10.26, df = 9, p-value = 0.3298
\end{verbatim}

Este código está implementado en la función \texttt{simres::freq.test()} (fichero \href{R/test.R}{\emph{test.R}}) y podríamos emplear:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(simres)}
\FunctionTok{freq.test}\NormalTok{(u, }\AttributeTok{nclass =}\NormalTok{ k)}
\CommentTok{\# Alternativamente}
\CommentTok{\# chisq.cont.test(u, distribution = "unif", nclass = k, output = FALSE, min = 0, max = 1)}
\end{Highlighting}
\end{Shaded}

\hypertarget{contraste-de-series}{%
\subsection{Contraste de series}\label{contraste-de-series}}

El contraste anterior se puede generalizar a contrastar la uniformidad de las \(d\)-uplas \((X_{t+1},X_{t+2},\ldots,X_{t+d})\) con \(t=(i-1)d\), \(i=1,\ldots,m\) siendo \(m=\lfloor n/d \rfloor\).
La idea es que troceamos el hipercubo \([0, 1]^d\) en \(K^d\) celdas equiprobables.
Considerando como categorías todos los posibles valores de las \(d\)-uplas, podemos emplear el estadístico chi-cuadrado para medir la discrepancia entre las frecuencias observadas y las esperadas, iguales todas a \(\frac{m}{K^d}\).
Las elecciones más frecuentes son \(d=2\) (contraste de pares seriados) y \(K=8\), \(10\) ó \(20\).
Por ejemplo, la función \texttt{serial.test()} del paquete \texttt{randtoolbox} implementa este contraste para \(d=2\).

Para que la prueba chi-cuadrado sea fiable el valor de \(n\) debería ser grande en comparación con el número de categorías \(K^d\) (e.g.~\(n \geq 5dK^d\)).
Si se considera un valor \(d \geq 3\) puede ser necesario reducir considerablemente el valor de \(K\) para evitar considerar demasiadas categorías.
Alternativamente se podrían considerar distintas técnicas para agrupar estas categorías, por ejemplo como se hace en el contraste del poker o del coleccionista descritos a continuación.

\hypertarget{el-contraste-del-poker}{%
\subsection{El contraste del poker}\label{el-contraste-del-poker}}

En el contrate del poker ``clásico'' se consideran conjuntos sucesivos de cinco enteros (\(d=5\)) y, para cada uno, se determina cuál de las siguientes posibilidades se da:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Un mismo entero se repite cinco veces (abreviadamente, \(AAAAA\)).
\item
  Un mismo entero se repite cuatro veces y otro distinto aparece una
  vez (\(AAAAB\)).
\item
  Un entero se repite tres veces y otro distinto se repite dos
  (\(AAABB\)).
\item
  Un entero se repite tres veces y otros dos distintos aparecen una
  vez cada uno (\(AAABC\)).
\item
  Un entero se repite dos veces, otro distinto se repite también dos
  veces y un tercer entero diferente aparece una sóla vez (\(AABBC\)).
\item
  Un entero se repite dos veces y otros tres distintos aparecen una
  vez cada uno (\(AABCD\)).
\item
  Los cinco enteros que aparecen son todos distintos (\(ABCDE\)).
\end{enumerate}

Bajo las hipótesis de aleatoriedad y uniformidad, se pueden calcular las probabilidades de estas modalidades. Por ejemplo para \(K=10\) obtendríamos:

\[\begin{aligned}
P(AAAAA) & =0.0001, P(AAAAB)=0.0045, P(AAABB)=0.0090,\\
P(AAABC) & =0.0720, P(AABBC)=0.1080, P(AABCD)=0.5040,\\
P(ABCDE) & =0.3024.
\end{aligned}\]

Es frecuente que las clases \(AAAAA\) y \(AAAAB\) se agrupen a la hora de
aplicar el test chi-cuadrado, ya que, en caso contrario, la restricción
habitual \(e_{i}\geq5\) llevaría a que \(0.0001\cdot\frac{n}{5}\geq5\), es
decir, \(n\geq250\,000\).

Es habitual simplificar el contraste anterior para facilitar su implementación definiendo las categorías según el número de enteros distintos de entre los cinco observados.
Así obtendríamos:
\[\begin{aligned}
P(\text{1 entero diferente}) & = 0.0001,
P(\text{2 enteros diferentes}) = 0.0135,\\
P(\text{3 enteros diferentes}) & = 0.1800, 
P(\text{4 enteros diferentes}) = 0.5040,\\
P(\text{5 enteros diferentes}) & = 0.3024,
\end{aligned}\]
procediendo también a agrupar las dos primeras modalidades.

En el caso general de considerar \(d\)-uplas (manos de \(d\) cartas con \(K\) posibilidades cada una), la probabilidad de obtener \(c\) valores (cartas) diferentes es (e.g.~Knuth, 2002, Sección 3.3.2, p.~64):
\[P(C=c) = \frac{K!}{(K-c)!K^d}S(d,c),\]
donde \(S(d,c)\) es el número de Stirling de segunda clase, definido como el número de formas que existen de hacer una partición de un conjunto de \(d\) elementos en \(c\) subconjuntos:
\[S(d,c) = \frac{1}{c!}\sum_{i=0}^{c} (-1)^{i} \binom{c}{i} (c-i)^d.\]
Por ejemplo, la función \texttt{poker.test()} del paquete \texttt{randtoolbox} implementa este contraste para el caso de \(d=K\).

\hypertarget{el-contraste-del-coleccionista}{%
\subsection{El contraste del coleccionista}\label{el-contraste-del-coleccionista}}

Por simplicidad describiremos el caso de \(d=1\) (con \(K\) categorías).
Considerando la sucesión de enteros aleatorios se procede (como un
coleccionista) a contabilizar cuál es el número, \(Q\), (aleatorio) de
valores consecutivos hasta que se completa la colección de todos los
enteros entre \(1\) y \(K\). Obviamente, bajo las hipótesis de aleatoriedad
y uniformidad, cada posible entero entre \(1\) y
\(K\) tiene la misma probabilidad de aparecer en cada generación y, por
tanto, resulta posible calcular la distribución de probabilidad de \(Q\).
De esta forma podemos utilizar los valores calculados de las probabilidades
\[P( Q = K ), P( Q = K+1 ),\ldots, P( Q = M -1 ), P( Q \geq M ),\]
para obtener las frecuencias esperadas de cada clase y confrontarlas con las
observadas vía el estadístico chi-cuadrado (e.g.~Knuth, 2002, Sección 3.3.2, p.~65).

Existen varias elecciones comunes de \(K\) y \(M\).
Tomando \(K=5\) con clases \(Q=5\), \(Q=6\), \(\ldots\), \(Q=19\), \(Q\geq20\), las probabilidades vendrían dadas por:
\[\begin{array}{rr}
P( Q = 5 ) = 0.03840000, \ & P( Q = 6 ) = 0.07680000,\\
P( Q = 7 ) = 0.09984000, \ & P( Q = 8 ) = 0.10752000,\\
P( Q = 9 ) = 0.10450944, \ & P( Q = 10 ) = 0.09547776,\\
P( Q = 11 ) = 0.08381645, \ & P( Q = 12 ) = 0.07163904,\\
P( Q = 13 ) = 0.06011299, \ & P( Q = 14 ) = 0.04979157,\\
P( Q = 15 ) = 0.04086200, \ & P( Q = 16 ) = 0.03331007,\\
P( Q = 17 ) = 0.02702163, \ & P( Q = 18 ) = 0.02184196,\\
P( Q = 19 ) = 0.01760857, \ & P( Q\geq20 ) = 0.07144851.
\end{array}\]

Para \(K=10\) se podrían considerar las siguientes categorías (con sus correspondientes probabilidades):
\[\begin{array}{rr}
P( 10 \leq Q \leq 19 ) = 0.17321155, \ & P( 20 \leq Q \leq 23 ) = 0.17492380,\\
P( 24 \leq Q \leq 27 ) = 0.17150818, \ & P( 28 \leq Q \leq 32 ) = 0.17134210,\\
P( 33 \leq Q \leq 39 ) = 0.15216056, \ & P( Q \geq 40 ) =0.15685380.
\end{array}\]

\hypertarget{int-num}{%
\chapter{Integración numérica}\label{int-num}}

En muchos casos nos puede interesar la aproximación de una integral definida.
En estadística, además del caso de Inferencia Bayesiana (que se trató en el Capítulo 11 empleando Integración Monte Carlo y MCMC), nos puede interesar por ejemplo aproximar mediante simulación el error cuadrático integrado medio (MISE) de un estimador.
Por ejemplo, en el caso de una densidad univariante sería de la forma:
\[MISE\left( \hat{f} \right) =\int E\left[ \left( \hat{f}(x) - f(x) \right)^2\right] dx\]

Cuando el numero de dimensiones es pequeño, nos puede interesar emplear un método numérico para aproximar este tipo de integrales.

\hypertarget{integraciuxf3n-numuxe9rica-unidimensional}{%
\section{Integración numérica unidimensional}\label{integraciuxf3n-numuxe9rica-unidimensional}}

Supongamos que nos interesa aproximar una integral de la forma:
\[I = \int_a^b h(x)  dx.\].

Consideraremos como ejemplo:
\[\int_0^1 4x^4 dx = \frac{4}{5}\].

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fun }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x) }\FunctionTok{return}\NormalTok{(}\DecValTok{4} \SpecialCharTok{*}\NormalTok{ x}\SpecialCharTok{\^{}}\DecValTok{4}\NormalTok{)}
\FunctionTok{curve}\NormalTok{(fun, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{h =} \DecValTok{0}\NormalTok{, }\AttributeTok{lty =} \DecValTok{2}\NormalTok{)}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{v =} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{), }\AttributeTok{lty =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{23-Integracion_numerica_files/figure-latex/unnamed-chunk-2-1} \end{center}

\hypertarget{muxe9todo-del-trapezoide}{%
\subsection{Método del trapezoide}\label{muxe9todo-del-trapezoide}}

La regla de los trapecios es una forma de aproximar la integral utilizando \(n\) trapecios.
Si se consideran \(n\) subintervalos en \([a,b]\) de longitud \(h= \frac{b-a}{n}\)
(i.e.~\(n + 1\) puntos regularmente espaciados cubriendo el dominio), y
se aproxima linealmente la función en cada subintervalo, se obtiene que:
\[\int_a^b f(x)\, dx \approx \frac{h}{2} [f(a)+2f(a+h)+2f(a+2h)+...+f(b)]\]

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{trapezoid.vec }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(f.vec, }\AttributeTok{h =} \FloatTok{0.01}\NormalTok{) \{}
\CommentTok{\# Integración numérica unidimensional entre a y b}
\CommentTok{\# utilizando el método del trapezoide }
\CommentTok{\# (se aproxima f linealmente en cada intervalo)}
\NormalTok{  n }\OtherTok{\textless{}{-}} \FunctionTok{length}\NormalTok{(f.vec) }
  \FunctionTok{return}\NormalTok{(h}\SpecialCharTok{*}\NormalTok{(f.vec[}\DecValTok{1}\NormalTok{]}\SpecialCharTok{/}\DecValTok{2} \SpecialCharTok{+} \FunctionTok{sum}\NormalTok{(f.vec[}\DecValTok{2}\SpecialCharTok{:}\NormalTok{(n}\DecValTok{{-}1}\NormalTok{)]) }\SpecialCharTok{+}\NormalTok{ f.vec[n]}\SpecialCharTok{/}\DecValTok{2}\NormalTok{))}
\NormalTok{\}}

\NormalTok{trapezoid }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(fun, }\AttributeTok{a =} \DecValTok{0}\NormalTok{, }\AttributeTok{b =} \DecValTok{1}\NormalTok{, }\AttributeTok{n =} \DecValTok{100}\NormalTok{) \{}
\CommentTok{\# Integración numérica de fun (función unidimensional) entre a y b}
\CommentTok{\# utilizando el método del trapezoide con n subdivisiones}
\CommentTok{\# (se aproxima f linealmente en cada intervalo)}
\CommentTok{\# Se asume a \textless{} b y n entero positivo }
\NormalTok{  h }\OtherTok{\textless{}{-}}\NormalTok{ (b}\SpecialCharTok{{-}}\NormalTok{a)}\SpecialCharTok{/}\NormalTok{n}
\NormalTok{  x.vec }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(a, b, }\AttributeTok{by =}\NormalTok{ h)}
\NormalTok{  f.vec }\OtherTok{\textless{}{-}} \FunctionTok{sapply}\NormalTok{(x.vec, fun)}
  \FunctionTok{return}\NormalTok{(}\FunctionTok{trapezoid.vec}\NormalTok{(f.vec, h))}
\NormalTok{\}}

\FunctionTok{trapezoid}\NormalTok{(fun, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{20}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.8033325
\end{verbatim}

El error en esta aproximación se corresponde con:
\[ \frac{(b-a)^3}{12n^2}\,f''(\xi), \]
para algún \(a\leq \xi \leq b\) (dependiendo del signo de la segunda derivada,
i.e.~de si la función es cóncava o convexa, el error será negativo ó positivo). El error
máximo absoluto es \(\frac{(b-a)^3}{12n^2}\max_{a\leq \xi \leq b}\left|f''(\xi)\right|\).
En el caso general multidimensional sería \(O(n^{-\frac{2}{d}})\).

\hypertarget{regla-de-simpson}{%
\subsection{Regla de Simpson}\label{regla-de-simpson}}

Se divide el intervalo \(n\) subintervalos de longitud \(h= \frac{b-a}{n}\) (con \(n\) par),
considerando \(n + 1\) puntos regularmente espaciados \(x_i = a + ih\), para \(i = 0, 1, ..., n\).
Aproximando de forma cuadrática la función en cada subintervalo \([x_{j-1},x_{j+1}]\)
(considerando 3 puntos), se obtiene que:
\[ \int_a^b f(x) \, dx \approx \frac{h}{3} \bigg[ 
f(x_0)+2\sum_{j=1}^{(n/2)-1}f(x_{2j})+ 4\sum_{j=1}^{n/2}f(x_{2j-1})+f(x_n) \bigg],\]

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{simpson }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(fun, a, b, }\AttributeTok{n =} \DecValTok{100}\NormalTok{) \{ }
\CommentTok{\# Integración numérica de fnt entre a y b}
\CommentTok{\# utilizando la regla de Simpson con n subdivisiones}
\CommentTok{\# (se aproxima fun de forma cuadrática en cada par de intervalos)  }
\CommentTok{\# fnt es una función de una sola variable}
\CommentTok{\# Se asume a \textless{} b y n entero positivo par }
\NormalTok{  n }\OtherTok{\textless{}{-}} \FunctionTok{max}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{2}\SpecialCharTok{*}\NormalTok{(n }\SpecialCharTok{\%/\%} \DecValTok{2}\NormalTok{), }\DecValTok{4}\NormalTok{))}
\NormalTok{  h }\OtherTok{\textless{}{-}}\NormalTok{ (b}\SpecialCharTok{{-}}\NormalTok{a)}\SpecialCharTok{/}\NormalTok{n}
\NormalTok{  x.vec1 }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(a}\SpecialCharTok{+}\NormalTok{h, b}\SpecialCharTok{{-}}\NormalTok{h, }\AttributeTok{by =} \DecValTok{2}\SpecialCharTok{*}\NormalTok{h)}
\NormalTok{  x.vec2 }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(a}\SpecialCharTok{+}\DecValTok{2}\SpecialCharTok{*}\NormalTok{h, b}\DecValTok{{-}2}\SpecialCharTok{*}\NormalTok{h, }\AttributeTok{by =} \DecValTok{2}\SpecialCharTok{*}\NormalTok{h)}
\NormalTok{  f.vec1 }\OtherTok{\textless{}{-}} \FunctionTok{sapply}\NormalTok{(x.vec1, fun)}
\NormalTok{  f.vec2 }\OtherTok{\textless{}{-}} \FunctionTok{sapply}\NormalTok{(x.vec2, fun)}
  \FunctionTok{return}\NormalTok{(h}\SpecialCharTok{/}\DecValTok{3}\SpecialCharTok{*}\NormalTok{(}\FunctionTok{fun}\NormalTok{(a) }\SpecialCharTok{+} \FunctionTok{fun}\NormalTok{(b) }\SpecialCharTok{+} \DecValTok{4}\SpecialCharTok{*}\FunctionTok{sum}\NormalTok{(f.vec1) }\SpecialCharTok{+} \DecValTok{2}\SpecialCharTok{*}\FunctionTok{sum}\NormalTok{(f.vec2)))}
  \CommentTok{\# Una cota del error en valor absoluto es:}
  \CommentTok{\# h\^{}4*(b{-}a)*max(c(f.vec1, fvec.2))\^{}4/180.}
\NormalTok{\}}

\FunctionTok{simpson}\NormalTok{(fun, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{20}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.8000033
\end{verbatim}

El máximo error (en el caso unidimensional) viene dado por la expresión:
\[\frac{(b-a)^5}{180n^4}\,\max_{a\leq \xi \leq b}\left| f^{(4)}(\xi) \right|.\]
En el caso general multidimensional sería \(O(n^{-\frac{4}{d}})\).

\hypertarget{cuadratura-adaptativa}{%
\subsection{Cuadratura adaptativa}\label{cuadratura-adaptativa}}

En lugar de evaluar la función en una rejilla regular (muestrear por igual el dominio),
puede interesar ir añadiendo puntos sólo en los lugares donde se mejore la aproximación
(en principio donde hay mayor área).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{quadrature }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(fun, a, b, }\AttributeTok{tol=}\FloatTok{1e{-}8}\NormalTok{) \{}
    \CommentTok{\# numerical integration using adaptive quadrature}

\NormalTok{  simpson2 }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(fun, a, b) \{}
    \CommentTok{\# numerical integral using Simpson\textquotesingle{}s rule}
    \CommentTok{\# assume a \textless{} b and n = 2}
    \FunctionTok{return}\NormalTok{((b}\SpecialCharTok{{-}}\NormalTok{a)}\SpecialCharTok{/}\DecValTok{6} \SpecialCharTok{*}\NormalTok{ (}\FunctionTok{fun}\NormalTok{(a) }\SpecialCharTok{+} \DecValTok{4}\SpecialCharTok{*}\FunctionTok{fun}\NormalTok{((a}\SpecialCharTok{+}\NormalTok{b)}\SpecialCharTok{/}\DecValTok{2}\NormalTok{) }\SpecialCharTok{+} \FunctionTok{fun}\NormalTok{(b)))}
\NormalTok{  \}}
 
\NormalTok{    quadrature\_internal }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(S.old, fun, a, m, b, tol, level) \{}
\NormalTok{        level.max }\OtherTok{\textless{}{-}} \DecValTok{100}
        \ControlFlowTok{if}\NormalTok{ (level }\SpecialCharTok{\textgreater{}}\NormalTok{ level.max) \{}
            \FunctionTok{cat}\NormalTok{ (}\StringTok{"recursion limit reached: singularity likely}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
            \FunctionTok{return}\NormalTok{ (}\ConstantTok{NULL}\NormalTok{)}
\NormalTok{        \}}
\NormalTok{        S.left }\OtherTok{\textless{}{-}} \FunctionTok{simpson2}\NormalTok{(fun, a, m) }
\NormalTok{        S.right }\OtherTok{\textless{}{-}} \FunctionTok{simpson2}\NormalTok{(fun, m, b)}
\NormalTok{        S.new }\OtherTok{\textless{}{-}}\NormalTok{ S.left }\SpecialCharTok{+}\NormalTok{ S.right}
        \ControlFlowTok{if}\NormalTok{ (}\FunctionTok{abs}\NormalTok{(S.new}\SpecialCharTok{{-}}\NormalTok{S.old) }\SpecialCharTok{\textgreater{}}\NormalTok{ tol) \{}
\NormalTok{            S.left }\OtherTok{\textless{}{-}} \FunctionTok{quadrature\_internal}\NormalTok{(S.left, fun, }
\NormalTok{                                          a, (a}\SpecialCharTok{+}\NormalTok{m)}\SpecialCharTok{/}\DecValTok{2}\NormalTok{, m, tol}\SpecialCharTok{/}\DecValTok{2}\NormalTok{, level}\SpecialCharTok{+}\DecValTok{1}\NormalTok{)}
\NormalTok{            S.right }\OtherTok{\textless{}{-}} \FunctionTok{quadrature\_internal}\NormalTok{(S.right, fun, }
\NormalTok{                                           m, (m}\SpecialCharTok{+}\NormalTok{b)}\SpecialCharTok{/}\DecValTok{2}\NormalTok{, b, tol}\SpecialCharTok{/}\DecValTok{2}\NormalTok{, level}\SpecialCharTok{+}\DecValTok{1}\NormalTok{)}
\NormalTok{            S.new }\OtherTok{\textless{}{-}}\NormalTok{ S.left }\SpecialCharTok{+}\NormalTok{ S.right}
\NormalTok{        \}}
        \FunctionTok{return}\NormalTok{(S.new)}
\NormalTok{    \}}
 
\NormalTok{    level }\OtherTok{=} \DecValTok{1}
\NormalTok{    S.old }\OtherTok{\textless{}{-}}\NormalTok{ (b}\SpecialCharTok{{-}}\NormalTok{a) }\SpecialCharTok{*}\NormalTok{ (}\FunctionTok{fun}\NormalTok{(a) }\SpecialCharTok{+} \FunctionTok{fun}\NormalTok{(b))}\SpecialCharTok{/}\DecValTok{2}
\NormalTok{    S.new }\OtherTok{\textless{}{-}} \FunctionTok{quadrature\_internal}\NormalTok{(S.old, fun, }
\NormalTok{                                 a, (a}\SpecialCharTok{+}\NormalTok{b)}\SpecialCharTok{/}\DecValTok{2}\NormalTok{, b, tol, level}\SpecialCharTok{+}\DecValTok{1}\NormalTok{)}
    \FunctionTok{return}\NormalTok{(S.new)}
\NormalTok{\}}

\FunctionTok{quadrature}\NormalTok{(fun, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.8
\end{verbatim}

Fuente: \href{https://www.r-bloggers.com/one-dimensional-integrals}{r-blogger Guangchuang Yu}

\hypertarget{comandos-de-r}{%
\subsection{Comandos de R}\label{comandos-de-r}}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{integrate}\NormalTok{(fun, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{)   }\CommentTok{\# Permite límites infinitos  }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 0.8 with absolute error < 8.9e-15
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Cuidado: fun debe ser vectorial...}

\FunctionTok{require}\NormalTok{(MASS)}
\FunctionTok{area}\NormalTok{(fun, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.8000001
\end{verbatim}

\hypertarget{integraciuxf3n-numuxe9rica-bidimensional}{%
\section{Integración numérica bidimensional}\label{integraciuxf3n-numuxe9rica-bidimensional}}

Supongamos que nos interesa aproximar una integral de la forma:
\[I=\int_{a_x}^{b_x}\int_{a_y}^{b_y}f(x, y)dy dx\].

Consideraremos como ejemplo:
\[\int_{-1}^{1} \int_{-1}^{1} \left( x^2 - y^2 \right) dx dy = 0\].

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f2d }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x,y) x}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{{-}}\NormalTok{ y}\SpecialCharTok{\^{}}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

Es habitual (especialmente en simulación) que la función se evalúe en una rejilla:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ax }\OtherTok{=} \SpecialCharTok{{-}}\DecValTok{1}
\NormalTok{ay }\OtherTok{=} \SpecialCharTok{{-}}\DecValTok{1}
\NormalTok{bx }\OtherTok{=} \DecValTok{1}
\NormalTok{by }\OtherTok{=} \DecValTok{1}
\NormalTok{nx }\OtherTok{=} \DecValTok{21}
\NormalTok{ny }\OtherTok{=} \DecValTok{21}
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(ax, bx, }\AttributeTok{length =}\NormalTok{ nx)}
\NormalTok{y }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(ay, by, }\AttributeTok{length =}\NormalTok{ ny)}
\NormalTok{z }\OtherTok{\textless{}{-}} \FunctionTok{outer}\NormalTok{(x, y, f2d)}

\NormalTok{hx }\OtherTok{\textless{}{-}}\NormalTok{ x[}\DecValTok{2}\NormalTok{]}\SpecialCharTok{{-}}\NormalTok{x[}\DecValTok{1}\NormalTok{]}
\NormalTok{hy }\OtherTok{\textless{}{-}}\NormalTok{ y[}\DecValTok{2}\NormalTok{]}\SpecialCharTok{{-}}\NormalTok{y[}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\hypertarget{representaciuxf3n-gruxe1fica}{%
\subsection{Representación gráfica}\label{representaciuxf3n-gruxe1fica}}

Puede ser de utilidad las herramientas de los paquetes \texttt{plot3D} y \texttt{plot3Drgl}
(también se pueden utilizar las funciones \texttt{spersp}, \texttt{simage}, \texttt{spoints} y \texttt{splot}
del paquete \texttt{npsp}).

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{(}\SpecialCharTok{!}\FunctionTok{require}\NormalTok{(plot3D)) }\FunctionTok{stop}\NormalTok{(}\StringTok{\textquotesingle{}Required pakage \textasciigrave{}plot3D\textasciigrave{} not installed.\textquotesingle{}}\NormalTok{)}

\CommentTok{\# persp3D(z = z, x = x, y = y)}

\NormalTok{persp3D.f2d }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(f2d, }\AttributeTok{ax=}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\AttributeTok{bx=}\DecValTok{1}\NormalTok{, }\AttributeTok{ay=}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\AttributeTok{by=}\DecValTok{1}\NormalTok{, }\AttributeTok{nx=}\DecValTok{21}\NormalTok{, }\AttributeTok{ny=}\DecValTok{21}\NormalTok{, ...) \{ }
\NormalTok{  x }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(ax, bx, }\AttributeTok{length =}\NormalTok{ nx)}
\NormalTok{  y }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(ay, by, }\AttributeTok{length =}\NormalTok{ ny)}
\NormalTok{  z }\OtherTok{\textless{}{-}} \FunctionTok{outer}\NormalTok{(x, y, f2d)}
  \FunctionTok{persp3D}\NormalTok{(x, y, z, ...)}
\NormalTok{\}}

\FunctionTok{persp3D.f2d}\NormalTok{(f2d, }\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{50}\NormalTok{, }\DecValTok{50}\NormalTok{, }\AttributeTok{ticktype =} \StringTok{"detailed"}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{23-Integracion_numerica_files/figure-latex/unnamed-chunk-9-1} \end{center}

\hypertarget{muxe9todo-del-trapezoide-1}{%
\subsection{Método del trapezoide}\label{muxe9todo-del-trapezoide-1}}

Error \(O(n^{-\frac{2}{d}})\).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{trapezoid.mat }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(z, hx, hy) \{ }
\CommentTok{\# Integración numérica bidimensional}
\CommentTok{\# utilizando el método del trapezoide (se aproxima f linealmente)}
\NormalTok{  f.vec }\OtherTok{\textless{}{-}} \FunctionTok{apply}\NormalTok{(z, }\DecValTok{1}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\FunctionTok{trapezoid.vec}\NormalTok{(x, hx))}
  \FunctionTok{return}\NormalTok{(}\FunctionTok{trapezoid.vec}\NormalTok{(f.vec, hy)) }
\NormalTok{\}}

\CommentTok{\# trapezoid.mat(z, hx, hy) }

\NormalTok{trapezoid.f2d }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(f2d, }\AttributeTok{ax=}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\AttributeTok{bx=}\DecValTok{1}\NormalTok{, }\AttributeTok{ay=}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\AttributeTok{by=}\DecValTok{1}\NormalTok{, }\AttributeTok{nx=}\DecValTok{21}\NormalTok{, }\AttributeTok{ny=}\DecValTok{21}\NormalTok{) \{ }
\NormalTok{  x }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(ax, bx, }\AttributeTok{length =}\NormalTok{ nx)}
\NormalTok{  y }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(ay, by, }\AttributeTok{length =}\NormalTok{ ny)}
\NormalTok{  hx }\OtherTok{\textless{}{-}}\NormalTok{ x[}\DecValTok{2}\NormalTok{]}\SpecialCharTok{{-}}\NormalTok{x[}\DecValTok{1}\NormalTok{]}
\NormalTok{  hy }\OtherTok{\textless{}{-}}\NormalTok{ y[}\DecValTok{2}\NormalTok{]}\SpecialCharTok{{-}}\NormalTok{y[}\DecValTok{1}\NormalTok{]}
\NormalTok{  z }\OtherTok{\textless{}{-}} \FunctionTok{outer}\NormalTok{(x, y, f2d)}
  \FunctionTok{trapezoid.mat}\NormalTok{(z, hx, hy)}
\NormalTok{\}}

\FunctionTok{trapezoid.f2d}\NormalTok{(f2d, }\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{101}\NormalTok{, }\DecValTok{101}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -8.881784e-18
\end{verbatim}

\hypertarget{comandos-de-r-1}{%
\subsection{Comandos de R}\label{comandos-de-r-1}}

Suponiendo que la función es vectorial, podemos emplear:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{integrate}\NormalTok{( }\ControlFlowTok{function}\NormalTok{(y) \{}
    \FunctionTok{sapply}\NormalTok{(y, }\ControlFlowTok{function}\NormalTok{(y) \{}
      \FunctionTok{integrate}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(x) }\FunctionTok{f2d}\NormalTok{(x,y), ax, bx)}\SpecialCharTok{$}\NormalTok{value \}) \}, }
\NormalTok{    ay, by)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## -2.775558e-17 with absolute error < 1.1e-14
\end{verbatim}

Si la función no es vectorial y solo admite parámetros escalares:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{integrate}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(y) \{}
    \FunctionTok{sapply}\NormalTok{(y, }\ControlFlowTok{function}\NormalTok{(y) \{}
      \FunctionTok{integrate}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(x) \{}
        \FunctionTok{sapply}\NormalTok{(x, }\ControlFlowTok{function}\NormalTok{(x) }\FunctionTok{f2d}\NormalTok{(x,y)) \}, ax, bx)}\SpecialCharTok{$}\NormalTok{value \}) \},}
\NormalTok{    ay, by)}
\end{Highlighting}
\end{Shaded}

Fuente: \href{http://tolstoy.newcastle.edu.au/R/help/04/10/5951.html}{tolstoy.newcastle.edu.au}.

Alternativamente se podría emplear la función \texttt{adaptIntegrate()} del paquete \texttt{cubature}.

\hypertarget{soluciones}{%
\chapter{Soluciones ejercicios}\label{soluciones}}

A continuación se muestran soluciones de algunos de los ejercicios no resueltos en el texto.

\hypertarget{capuxedtulo-1-introducciuxf3n-a-la-simulaciuxf3n}{%
\section{\texorpdfstring{Capítulo 1 \href{intro.html}{Introducción a la simulación}}{Capítulo 1 Introducción a la simulación}}\label{capuxedtulo-1-introducciuxf3n-a-la-simulaciuxf3n}}

\hypertarget{sol-simpi}{%
\subsection{\texorpdfstring{Ejercicio \href{ejercicios.html\#exr:simpi}{1.1}}{Ejercicio 1.1}}\label{sol-simpi}}

Enunciado \ref{exr:simpi}:

Sea \((X,Y)\) es un vector aleatorio con distribución uniforme en el
cuadrado \([-1,1]\times\lbrack-1,1]\) de área 4.

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\tightlist
\item
  Aproximar mediante simulación \(P\left(X + Y \leq 0 \right)\) y
  compararla con la probabilidad teórica (obtenida aplicando la
  regla de Laplace \(\frac{\text{área favorable}}{\text{área posible}}\)).
\end{enumerate}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

Generamos \texttt{nsim\ =\ 10000} valores del proceso bidimensional:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{nsim }\OtherTok{\textless{}{-}} \DecValTok{10000}
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{runif}\NormalTok{(nsim, }\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{y }\OtherTok{\textless{}{-}} \FunctionTok{runif}\NormalTok{(nsim, }\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

La probabilidad teórica es 1/2 y la aproximación por simulación es la frecuencia relativa del suceso en los valores generados (para calcularla podemos aprovechar que R maneja internamente los valores lógicos como 1, \texttt{TRUE}, y 0, \texttt{FALSE}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{indice }\OtherTok{\textless{}{-}}\NormalTok{ (x }\SpecialCharTok{+}\NormalTok{ y }\SpecialCharTok{\textless{}} \DecValTok{0}\NormalTok{)}
\FunctionTok{sum}\NormalTok{(indice)}\SpecialCharTok{/}\NormalTok{nsim}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.4996
\end{verbatim}

Alternativamente (la frecuencia relativa es un caso particular de la media) se puede obtener de forma más simple como:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(indice)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.4996
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\setcounter{enumi}{1}
\tightlist
\item
  Aproximar el valor de \(\pi\) mediante simulación a partir de
  \(P\left( X^2 +Y^2 \leq 1 \right)\).
\end{enumerate}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{10000}
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{runif}\NormalTok{(n, }\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{y }\OtherTok{\textless{}{-}} \FunctionTok{runif}\NormalTok{(n, }\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{indice }\OtherTok{\textless{}{-}}\NormalTok{ (x}\SpecialCharTok{\^{}}\DecValTok{2}\SpecialCharTok{+}\NormalTok{y}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{\textless{}} \DecValTok{1}\NormalTok{)}
\FunctionTok{mean}\NormalTok{(indice)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.7806
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pi}\SpecialCharTok{/}\DecValTok{4}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.7853982
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pi\_aprox }\OtherTok{\textless{}{-}} \DecValTok{4}\SpecialCharTok{*}\FunctionTok{mean}\NormalTok{(indice)}
\NormalTok{pi\_aprox}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3.1224
\end{verbatim}

Generamos el correspondiente gráfico (ver Figura \ref{fig:simpiplot}) (los puntos con color negro tienen distribución uniforme en el círculo unidad; esto está relacionado con el método de aceptación-rechazo, ver Ejemplo \ref{exm:ar-esfera}, o con el denominado método \emph{hit-or-miss}).

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Colores y símbolos dependiendo de si el índice correspondiente es verdadero:}
\NormalTok{color }\OtherTok{\textless{}{-}} \FunctionTok{ifelse}\NormalTok{(indice, }\StringTok{"black"}\NormalTok{, }\StringTok{"red"}\NormalTok{) }
\NormalTok{simbolo }\OtherTok{\textless{}{-}} \FunctionTok{ifelse}\NormalTok{(indice, }\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\FunctionTok{plot}\NormalTok{(x, y, }\AttributeTok{pch =}\NormalTok{ simbolo, }\AttributeTok{col =}\NormalTok{ color, }
     \AttributeTok{xlim =} \FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{), }\AttributeTok{ylim =} \FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{), }\AttributeTok{xlab=}\StringTok{"X"}\NormalTok{, }\AttributeTok{ylab=}\StringTok{"Y"}\NormalTok{, }\AttributeTok{asp =} \DecValTok{1}\NormalTok{) }
     \CommentTok{\# asp = 1 para dibujar circulo}
\FunctionTok{symbols}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\AttributeTok{circles =} \DecValTok{1}\NormalTok{, }\AttributeTok{inches =} \ConstantTok{FALSE}\NormalTok{, }\AttributeTok{add =} \ConstantTok{TRUE}\NormalTok{)}
\FunctionTok{symbols}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\AttributeTok{squares =} \DecValTok{2}\NormalTok{, }\AttributeTok{inches =} \ConstantTok{FALSE}\NormalTok{, }\AttributeTok{add =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[!htb]

{\centering \includegraphics[width=0.7\linewidth]{24-Soluciones_files/figure-latex/simpiplot-1} 

}

\caption{Valores generados con distribución uniforme bidimensional, con colores y símbolos indicando si están dentro del círculo unidad.}\label{fig:simpiplot}
\end{figure}

\hypertarget{sol-bernoulli}{%
\subsection{\texorpdfstring{Ejercicio \href{ejercicios.html\#exr:bernoulli}{1.2}}{Ejercicio 1.2}}\label{sol-bernoulli}}

Enunciado \ref{exr:bernoulli}:

Consideramos el experimento de Bernoulli consistente en el
lanzamiento de una moneda.

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\tightlist
\item
  Empleando la función \texttt{sample}, obtener 1000 simulaciones del
  lanzamiento de una moneda \texttt{(0\ =\ cruz,\ 1\ =\ cara)}, suponiendo que
  no está trucada. Aproximar la probabilidad de cara a partir de
  las simulaciones.
\end{enumerate}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{nsim }\OtherTok{\textless{}{-}} \DecValTok{10000}
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\AttributeTok{cara =} \DecValTok{1}\NormalTok{, }\AttributeTok{cruz =} \DecValTok{0}\NormalTok{), nsim, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{prob =} \FunctionTok{c}\NormalTok{(}\FloatTok{0.5}\NormalTok{,}\FloatTok{0.5}\NormalTok{))}
\FunctionTok{mean}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.4953
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{barplot}\NormalTok{(}\DecValTok{100}\SpecialCharTok{*}\FunctionTok{table}\NormalTok{(x)}\SpecialCharTok{/}\NormalTok{nsim, }\AttributeTok{ylab =} \StringTok{"Porcentaje"}\NormalTok{) }\CommentTok{\# Representar porcentajes }
\end{Highlighting}
\end{Shaded}

\begin{figure}[!htb]

{\centering \includegraphics[width=0.7\linewidth]{24-Soluciones_files/figure-latex/simberplot-1} 

}

\caption{Frecuencias relativas de los valores generados con distribución Bernoulli (aproximaciones por simulación de las probabilidades teóricas).}\label{fig:simberplot}
\end{figure}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\setcounter{enumi}{1}
\tightlist
\item
  En R pueden generarse valores de la distribución de Bernoulli
  mediante la función \texttt{rbinom(nsim,\ size=1,\ prob)}. Generar un
  gráfico de lineas considerando en el eje \(X\) el número de
  lanzamientos (de 1 a 10000) y en el eje \(Y\) la frecuencia
  relativa del suceso cara (puede ser recomendable emplear la
  función \texttt{cumsum}).
\end{enumerate}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{nsim }\OtherTok{\textless{}{-}} \DecValTok{1000}
\NormalTok{p }\OtherTok{\textless{}{-}} \FloatTok{0.4}
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{rbinom}\NormalTok{(nsim, }\AttributeTok{size =} \DecValTok{1}\NormalTok{, }\AttributeTok{prob =}\NormalTok{ p) }\CommentTok{\# Simulamos una Bernoulli}
\CommentTok{\# Alternativa programación: x \textless{}{-} runif(nsim) \textless{} p}
\FunctionTok{mean}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.394
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\NormalTok{nsim}
\FunctionTok{plot}\NormalTok{(n, }\FunctionTok{cumsum}\NormalTok{(x)}\SpecialCharTok{/}\NormalTok{n, }\AttributeTok{type=}\StringTok{"l"}\NormalTok{, }\AttributeTok{ylab=}\StringTok{"Proporción de caras"}\NormalTok{, }
     \AttributeTok{xlab=}\StringTok{"Número de lanzamientos"}\NormalTok{, }\AttributeTok{ylim=}\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{))}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{h=}\NormalTok{p, }\AttributeTok{lty=}\DecValTok{2}\NormalTok{, }\AttributeTok{col=}\StringTok{"red"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[!htb]

{\centering \includegraphics[width=0.7\linewidth]{24-Soluciones_files/figure-latex/simberconv-1} 

}

\caption{Gráfico de convergencia de la aproximación por simulación a la probabilidad teórica.}\label{fig:simberconv}
\end{figure}

\hypertarget{sol-circuito}{%
\subsection{\texorpdfstring{Ejercicio \href{ejercicios.html\#exr:circuito}{1.3}}{Ejercicio 1.3}}\label{sol-circuito}}

Enunciado \ref{exr:circuito}:

Simular el paso de corriente a través del siguiente circuito, donde
figuran las probabilidades de que pase corriente por cada uno de los
interruptores:

\begin{center}\includegraphics[width=0.5\linewidth]{images/circuito2} \end{center}

Considerar que cada interruptor es una variable aleatoria de Bernoulli independiente
para simular 1000 valores de cada una de ellas.

\begin{remark}
\iffalse{} {Nota: } \fi{}R maneja internamente los valores lógicos como 1 (\texttt{TRUE}) y 0 (\texttt{FALSE}).
Recíprocamente, cualquier número puede ser tratado como lógico (al estilo de C).
El entero 0 es equivalente a \texttt{FALSE} y cualquier entero distinto de 0 a \texttt{TRUE}.
\end{remark}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{nsim }\OtherTok{\textless{}{-}} \DecValTok{10000}
\NormalTok{x1 }\OtherTok{\textless{}{-}} \FunctionTok{rbinom}\NormalTok{(nsim, }\AttributeTok{size=}\DecValTok{1}\NormalTok{, }\AttributeTok{prob=}\FloatTok{0.8}\NormalTok{)}
\NormalTok{x2 }\OtherTok{\textless{}{-}} \FunctionTok{rbinom}\NormalTok{(nsim, }\AttributeTok{size=}\DecValTok{1}\NormalTok{, }\AttributeTok{prob=}\FloatTok{0.9}\NormalTok{)}
\NormalTok{z1 }\OtherTok{\textless{}{-}}\NormalTok{ x1 }\SpecialCharTok{|}\NormalTok{ x2   }\CommentTok{\# Operador lógico "O"}
\NormalTok{x3 }\OtherTok{\textless{}{-}} \FunctionTok{rbinom}\NormalTok{(nsim, }\AttributeTok{size=}\DecValTok{1}\NormalTok{, }\AttributeTok{prob=}\FloatTok{0.6}\NormalTok{)}
\NormalTok{x4 }\OtherTok{\textless{}{-}} \FunctionTok{rbinom}\NormalTok{(nsim, }\AttributeTok{size=}\DecValTok{1}\NormalTok{, }\AttributeTok{prob=}\FloatTok{0.5}\NormalTok{)}
\NormalTok{z2 }\OtherTok{\textless{}{-}}\NormalTok{ x3 }\SpecialCharTok{|}\NormalTok{ x4}
\NormalTok{z3 }\OtherTok{\textless{}{-}}\NormalTok{ z1 }\SpecialCharTok{|}\NormalTok{ z2}
\NormalTok{x5 }\OtherTok{\textless{}{-}} \FunctionTok{rbinom}\NormalTok{(nsim, }\AttributeTok{size=}\DecValTok{1}\NormalTok{, }\AttributeTok{prob=}\FloatTok{0.7}\NormalTok{)}
\NormalTok{fin }\OtherTok{\textless{}{-}}\NormalTok{ z3 }\SpecialCharTok{\&}\NormalTok{ x5  }\CommentTok{\# Operador lógico "Y"}
\FunctionTok{mean}\NormalTok{(fin)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.692
\end{verbatim}

\hypertarget{sol-mere}{%
\subsection{\texorpdfstring{Ejercicio \href{ejercicios.html\#exr:mere}{1.4}}{Ejercicio 1.4}}\label{sol-mere}}

Enunciado \ref{exr:mere} (el problema del Caballero de Méré):

En 1651, el Caballero de Méré le planteó a Pascal una pregunta
relacionada con las apuestas y los juegos de azar: ¿es ventajoso
apostar a que en cuatro lanzamientos de un dado se obtiene al menos
un seis? Este problema generó una fructífera correspondencia entre
Pascal y Fermat que se considera, simbólicamente, como el nacimiento
del Cálculo de Probabilidades.

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\tightlist
\item
  Escribir una función que simule el lanzamiento de \(n\) dados. El
  parámetro de entrada es el número de lanzamientos \(n\), que toma
  el valor 4 por defecto, y la salida debe ser \texttt{TRUE} si se
  obtiene al menos un 6 y \texttt{FALSE} en caso contrario.
\end{enumerate}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deMere }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(}\AttributeTok{n =} \DecValTok{4}\NormalTok{)\{}
\NormalTok{  lanz }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{6}\NormalTok{, }\AttributeTok{replace=}\ConstantTok{TRUE}\NormalTok{, }\AttributeTok{size=}\NormalTok{n)}
  \FunctionTok{return}\NormalTok{(}\DecValTok{6} \SpecialCharTok{\%in\%}\NormalTok{ lanz)}
\NormalTok{\}}

\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{4}
\NormalTok{lanz }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{6}\NormalTok{, }\AttributeTok{replace=}\ConstantTok{TRUE}\NormalTok{, }\AttributeTok{size=}\NormalTok{n)}
\NormalTok{lanz}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3 5 1 6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{6} \SpecialCharTok{\%in\%}\NormalTok{ lanz}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\setcounter{enumi}{1}
\tightlist
\item
  Utilizar la función anterior para simular \(nsim=10000\) jugadas
  de este juego y calcular la proporción de veces que se gana la
  apuesta (obtener al menos un 6 en \(n\) lanzamientos), usando
  \(n=4\). Comparar el resultado con la probabilidad teórica
  \(1-(5/6)^{n}\).
\end{enumerate}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{4}
\NormalTok{nsim }\OtherTok{\textless{}{-}} \DecValTok{10000}
\FunctionTok{mean}\NormalTok{(}\FunctionTok{replicate}\NormalTok{(nsim, }\FunctionTok{deMere}\NormalTok{(n)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.5148
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{(}\DecValTok{5}\SpecialCharTok{/}\DecValTok{6}\NormalTok{)}\SpecialCharTok{\^{}}\NormalTok{n}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.5177469
\end{verbatim}

\hypertarget{sol-album}{%
\subsection{\texorpdfstring{Ejercicio \href{ejercicios.html\#exr:album}{1.5}}{Ejercicio 1.5}}\label{sol-album}}

Enunciado \ref{exr:album} (variación del problema del coleccionista, cadena de Markov):

Continuando con el ejemplo de la Sección \ref{ealbum}
(álbum con \(n = 75\) cromos y sobres con \(m = 6\)). A partir de \(nsim=2000\) simulaciones de coleccionistas de cromos, aproximar por simulación la evolución del proceso de compra de un coleccionista (número de cromos distintos dependiendo de los sobres comprados).

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

Generamos \texttt{nsim\ =\ 2000} simulaciones de coleccionistas de cromos:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Parámetros}
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{75} \CommentTok{\# Número total de cromos}
\NormalTok{m }\OtherTok{\textless{}{-}} \DecValTok{6}  \CommentTok{\# Número de cromos en cada sobre}
\NormalTok{repe }\OtherTok{\textless{}{-}} \ConstantTok{TRUE} \CommentTok{\# Repetición de cromos en cada sobre}

\CommentTok{\# Número de simulaciones}
\NormalTok{nsim }\OtherTok{\textless{}{-}} \DecValTok{2000}

\CommentTok{\# Resultados simulación}
\NormalTok{nsobres }\OtherTok{\textless{}{-}} \FunctionTok{numeric}\NormalTok{(nsim)      }\CommentTok{\# Número de sobres}
\NormalTok{evol }\OtherTok{\textless{}{-}} \FunctionTok{vector}\NormalTok{(}\StringTok{"list"}\NormalTok{, nsim)  }\CommentTok{\# Evolución del número de cromos}
\CommentTok{\# Por comodidad se podría haber fijado un número máximo de cromos}
\CommentTok{\# evol \textless{}{-} matrix(nrow = max\_len, ncol = nsim)}

\CommentTok{\# Fijar semilla}
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\CommentTok{\# Bucle simulación}
\ControlFlowTok{for}\NormalTok{ (isim }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\NormalTok{nsim) \{}
  \CommentTok{\# seed \textless{}{-} .Random.seed \# .Random.seed \textless{}{-} seed}
  \CommentTok{\# Simular}
\NormalTok{  album }\OtherTok{\textless{}{-}} \FunctionTok{logical}\NormalTok{(n)}
\NormalTok{  evolucion }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{()}
\NormalTok{  i }\OtherTok{\textless{}{-}} \DecValTok{0} \CommentTok{\# Número de sobres}
  \ControlFlowTok{repeat}\NormalTok{\{}
\NormalTok{    i }\OtherTok{\textless{}{-}}\NormalTok{ i }\SpecialCharTok{+} \DecValTok{1}
\NormalTok{    sobre }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(n, m, }\AttributeTok{replace =}\NormalTok{ repe)}
\NormalTok{    album[sobre] }\OtherTok{\textless{}{-}} \ConstantTok{TRUE}
\NormalTok{    ncromos }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(album)}
\NormalTok{    evolucion }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(evolucion, ncromos)}
    \ControlFlowTok{if}\NormalTok{ (ncromos }\SpecialCharTok{==}\NormalTok{ n) \{}
\NormalTok{      nsobres[isim] }\OtherTok{\textless{}{-}}\NormalTok{ i}
\NormalTok{      evol[[isim]] }\OtherTok{\textless{}{-}}\NormalTok{ evolucion}
      \ControlFlowTok{break}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{\}}
\CommentTok{\# simres::plot.sr(nsobres)}
\end{Highlighting}
\end{Shaded}

\texttt{evol} contiene las realizaciones de la cadena de Markov.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# plot(evol[[1]], type = "l")}
\end{Highlighting}
\end{Shaded}

Combinar realizaciones del proceso (evoluciones del número de cromos):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Se extienden a la máxima longitud}
\NormalTok{max\_len }\OtherTok{\textless{}{-}} \FunctionTok{max}\NormalTok{(}\FunctionTok{lengths}\NormalTok{(evol)) }\CommentTok{\# max(sapply(evol, length))}
\NormalTok{evol }\OtherTok{\textless{}{-}} \FunctionTok{sapply}\NormalTok{(evol, }\ControlFlowTok{function}\NormalTok{(x) }\FunctionTok{c}\NormalTok{(x, }\FunctionTok{rep}\NormalTok{(n, max\_len }\SpecialCharTok{{-}} \FunctionTok{length}\NormalTok{(x))))}
\FunctionTok{str}\NormalTok{(evol)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  num [1:167, 1:2000] 6 12 16 21 23 25 30 34 37 38 ...
\end{verbatim}

Aproximar cuantiles (intervalos de predicción):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{alpha }\OtherTok{\textless{}{-}} \FloatTok{0.05}
\NormalTok{limits }\OtherTok{\textless{}{-}} \FunctionTok{apply}\NormalTok{(evol, }\DecValTok{1}\NormalTok{, quantile, }\AttributeTok{probs =} \FunctionTok{c}\NormalTok{(alpha, }\FloatTok{0.5}\NormalTok{, }\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{alpha))}
\FunctionTok{str}\NormalTok{(limits)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  num [1:3, 1:167] 5 6 6 10 11 12 14 16 18 18 ...
##  - attr(*, "dimnames")=List of 2
##   ..$ : chr [1:3] "5%" "50%" "95%"
##   ..$ : NULL
\end{verbatim}

Ejemplo, aproximación de los límites (y mediana) para el número de cromos en el álbum después de comprar 20 sobres:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{limits[, }\DecValTok{20}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  5% 50% 95% 
##  55  60  64
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{hist}\NormalTok{(evol[}\DecValTok{20}\NormalTok{, ], }\AttributeTok{breaks =} \StringTok{"FD"}\NormalTok{, }\AttributeTok{freq =} \ConstantTok{FALSE}\NormalTok{,}
     \AttributeTok{main =} \StringTok{""}\NormalTok{, }\AttributeTok{xlab =} \StringTok{"Número de cromos distintos (en 20 sobres)"}\NormalTok{)}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{v =}\NormalTok{ limits[, }\DecValTok{20}\NormalTok{], }\AttributeTok{lty =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{24-Soluciones_files/figure-latex/unnamed-chunk-15-1} \end{center}

Representar las realizaciones del proceso y los intervalos de predicción puntuales:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{matplot}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\NormalTok{max\_len, evol, }\AttributeTok{type =} \StringTok{"l"}\NormalTok{, }\AttributeTok{col =} \StringTok{"lightgray"}\NormalTok{, }\AttributeTok{lty =} \DecValTok{1}\NormalTok{,}
    \AttributeTok{xlab=}\StringTok{"Número de sobres"}\NormalTok{, }\AttributeTok{ylab=}\StringTok{"Número de cromos distintos"}\NormalTok{)}
\FunctionTok{matlines}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\NormalTok{max\_len, }\FunctionTok{t}\NormalTok{(limits), }\AttributeTok{lty =} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{), }\AttributeTok{col =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{24-Soluciones_files/figure-latex/unnamed-chunk-16-1} \end{center}

\hypertarget{capuxedtulo-2-generaciuxf3n-de-nuxfameros-pseudoaleatorios}{%
\section{\texorpdfstring{Capítulo 2 \href{gen-pseudo.html}{Generación de números pseudoaleatorios}}{Capítulo 2 Generación de números pseudoaleatorios}}\label{capuxedtulo-2-generaciuxf3n-de-nuxfameros-pseudoaleatorios}}

\hypertarget{sol-RANDVN}{%
\subsection{\texorpdfstring{Ejercicio \href{ejercicios.html\#exr:RANDVN}{2.1}}{Ejercicio 2.1}}\label{sol-RANDVN}}

Enunciado \ref{exr:RANDVN}:

Uno de los primeros generadores utilizados fue el denominado método de los
cuadrados medios propuesto por Von Neumann (1946). Con este
procedimiento se generan números pseudoaleatorios de 4 dígitos de la
siguiente forma:

\begin{enumerate}
\def\labelenumi{\roman{enumi}.}
\item
  Se escoge un número de cuatro dígitos \(x_0\) (semilla).
\item
  Se eleva al cuadrado (\(x_0^2\)) y se toman los cuatro dígitos centrales (\(x_1\)).
\item
  Se genera el número pseudo-aleatorio como \[u_1=\frac{x_1}{10^{4}}.\]
\item
  Volver al paso ii y repetir el proceso.
\end{enumerate}

Para obtener los \(k\) (número par) dígitos centrales de \(x_{i}^2\)
se puede utilizar que:
\[x_{i+1}=\left\lfloor \left(  x_{i}^2-\left\lfloor \dfrac{x_{i}^2}{10^{(2k-\frac{k}2)}}\right\rfloor 10^{(2k-\frac{k}2)}\right)
/10^{\frac{k}2}\right\rfloor\]

Este algoritmo está implementado en la función \texttt{simres::rvng()} (ver también \texttt{simres::rng()}; fichero \href{R/rng.R}{\emph{rng.R}}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{simres}\SpecialCharTok{::}\NormalTok{rvng}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## function(n, seed = as.numeric(Sys.time()), k = 4) {
##   seed <- seed %% 10^k
##   aux <- 10^(2*k-k/2)
##   aux2 <- 10^(k/2)
##   u <- numeric(n)
##   for(i in 1:n) {
##     z <- seed^2
##     seed <- trunc((z - trunc(z/aux)*aux)/aux2)
##     u[i] <- seed/10^k
##   }
##   # Almacenar semilla y parámetros
##   assign(".rng", list(seed = seed, type = "vm", parameters = list(k = k)),
##       envir = globalenv())
##   # .rng <<- list(seed = seed, type = "vm", parameters = list(k = k))
##   # Para continuar con semilla y parámetros:
##   #   with(.rng, rvng(n, seed, parameters$k))
##   # Devolver valores
##   return(u)
## }
## <bytecode: 0x00000000374080b0>
## <environment: namespace:simres>
\end{verbatim}

Estudiar las características del generador de cuadrados medios a partir de una secuencia de 500 valores.
Emplear únicamente métodos gráficos.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

  \bibliography{book.bib,packages.bib}

\end{document}
